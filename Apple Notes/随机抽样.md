<span style="font-family:.PingFangUITextSC-Regular;">好的</span>,在迭代,我们定义这个 PROMPT 叫随机抽样,
定义A:/Users/didi/Downloads/panth/tag_ct/overlap/00_更新结果/20250902/结果表2_重叠站标签更新表_20250902.xlsx

定义 B: /Users/didi/Downloads/panth/tag_ct/overlap/01_历史结果/2025-33.xlsx


A/B 中都有 store_id,is_overlap 字段

<span style="font-family:.PingFangUITextSC-Regular;">取</span> A <span style="font-family:.PingFangUITextSC-Regular;">表的</span>store_id,pop_id 

| province |
| -- |



| store_level_mtd_v2 |
| -- |


再产出一个新的is_overlap 字段,命名is_overlap_c,取数逻辑,优先B 后 A,如果 AB 都没有数据则用空值表示

返回 A 表的全部字段,增加is_overlap_c,是否随机抽样

随机抽样的方法,根据这个 PROMPT 来

[

## **随机抽样 PROMPT**
**输入参数说明**
		**样本标识信息（ids）**：
		这是一个包含所有样本唯一标识（如 store_id、pop_id 等）的列表，AI 可通过对这个列表的长度统计来获取总体规模（即总体产品数量）。例如 去重统计 Id 数量代表了产品的总体个数。
		**分层属性列表（Attributes）**：
		是一个由用于对总体进行分层的属性名称组成的列表，比如 Attributes = [province,store_level_mtd_v2<span style="font-family:.CJKSymbolsFallbackSC-Regular;">]</span><span style="font-family:.PingFangUITextSC-Regular;">，这些属性将作为划分总体为不同层次的依据，</span>AI <span style="font-family:.PingFangUITextSC-Regular;">需要依据这些属性来区分不同类别的产品进行分层抽样。</span>
		**预估具有特定质量特征的比例（p）**：0.8
		根据过往产品质量检测的历史数据或者专家经验预估在总体中具有某种关键质量特征（比如合格产品的大致比例）的产品所占比例，取值范围在 0 到 1 之间，需人工输入，例如 p = 0.8（表示预估 80% 的产品具有该质量特征），若没有过往经验可暂设为 0.5 作为保守估计。
		**允许的误差范围（e）**：5%
		结合期望的精度要求（大于 90%）来设定的允许抽样结果与总体实际情况之间的误差范围，取值范围在 0 到 1 之间，属于人工输入参数，例如 e = 0.05（表示允许 5% 的误差）。
		**置信水平对应的 Z 值（Z）**：置信水平 90%
		根据 置信水平反算 Z,输入值是置信水平
		**各层最小抽样数量字典（Min_Sample_Dict）**：
		以分层属性的不同取值作为键（比如各生产批次编号、产品型号名称等），对应的最小抽样数量作为值，例如 Min_Sample_Dict = {province 10,store_level_mtd_v2 10}，这是根据业务实际要求人为设定的参数，确保每个有意义的分层类别都有最低抽样个数保障。
**自动计算步骤及逻辑**
		**计算总体规模（N）**：
		**逻辑**：通过计算输入的样本标识信息列表（ids）的长度来确定总体规模，即 N = len(ids)，例如若 ids 列表中有 10000 个元素，那么 N = 10000，代表总体产品数量为 10000 个。
		**各层产品数量统计（Layer_N_Dict）**：
		**逻辑**：遍历样本标识信息对应的所有产品数据（可假设能通过 ids 关联获取到完整产品信息），依据分层属性列表（Attributes）中的每个属性对产品进行分类统计，得到一个以各分层属性取值为键（如不同生产批次名称），对应该层产品数量为值的字典。例如，如果 Attributes 包含 “生产批次”，统计后得到类似 Layer_N_Dict = {"批次 1": 2000, "批次 2": 3000} 表示 “批次 1” 有 2000 个产品，“批次 2” 有 3000 个产品等。
		**各层占总体比例计算（Layer_P_Dict）**：
		**逻辑**：对于 Layer_N_Dict 中的每个键值对（即每个分层），计算该层产品数量占总体规模（N）的比例，生成一个新的字典 Layer_P_Dict，其键与 Layer_N_Dict 相同，值为对应层占总体的比例。计算公式为：Layer_P_Dict[layer] = Layer_N_Dict[layer] / N，例如对于上述的 “批次 1” 层，其占比为 2000 / 10000 = 0.2。
		**总体最小抽样数量计算（Total_Min_Sample）**：
		**逻辑**：使用统计学抽样公式计算满足精度要求下的总体最小抽样数量，公式为 Total_Min_Sample = (Z ** 2 * p * (1 - p)) / e ** 2，将输入的 Z、p、e 值代入公式进行计算，例如按照上述给定的 Z = 1.645、p = 0.8、e = 0.05，计算可得 Total_Min_Sample = (1.645 ** 2 * 0.8 * (1 - 0.8)) / 0.05 ** 2≈ 174（向上取整）。
		**各层初始抽样数量分配（Initial_Sample_Dict）**：
		**逻辑**：根据各层占总体比例（Layer_P_Dict）将总体最小抽样数量（Total_Min_Sample）分配到各层，生成 Initial_Sample_Dict，计算公式为 Initial_Sample_Dict[layer] = round(Total_Min_Sample * Layer_P_Dict[layer])（使用 round 函数进行四舍五入取整），例如对于 “批次 1” 层，其初始抽样数量可能为 round(174 * 0.2) = 35（假设）。
		**各层实际抽样数量确定（Final_Sample_Dict）**：
		**逻辑**：对比各层初始抽样数量（Initial_Sample_Dict）与各层最小抽样数量字典（Min_Sample_Dict），若某层初始抽样数量低于保底数量，则将该层抽样数量调整为保底数量，同时按比例适当调整其他层的抽样数量，以保证总体抽样数量满足精度要求且各层达到保底抽样。具体调整方式可通过循环迭代，先将低于保底的层设为保底数量，然后重新计算剩余层可分配的抽样数量，直至所有层的抽样数量都确定下来，最终得到 Final_Sample_Dict。
**实施随机抽样与标签标注**
		**对各层产品编号**：
		针对每一层，按照顺序为该层内的所有产品从 1 开始依次编号，确保每个产品都有唯一编号，例如 “批次 1” 层的产品编号为 1 到 2000（假设该层有 2000 个产品）。
		**生成随机数并抽取样本**：
		对于每个层，使用合适的随机数生成工具（AI 可调用相关的函数库或者工具，如 Python 中的 random 模块等），根据该层实际抽样数量（Final_Sample_Dict 中对应的值），生成对应数量的不重复随机数，这些随机数的范围应与该层产品编号范围相匹配。例如对于 “批次 1” 层，若 Final_Sample_Dict 中该层抽样数量为 35，则生成 35 个在 1 到 2000 之间的不重复随机数。
			- 依据生成的随机数所对应的产品编号，抽取相应的产品作为该层的样本。
		**标注抽样标签**：是否随机抽样
		创建一个与样本标识信息（ids）长度相等的标签列表（初始值全为 0，表示不抽样），例如若 ids 长度为 10000，创建一个长度为 10000 的列表，元素初始值都为 0。
			- 当抽取某产品作为样本时，将对应位置的标签值修改为 1，表示抽样。例如，若抽取了编号为 500 的产品（属于总体中的某个产品），则将标签列表中第 500 个元素的值改为 1。最终这个标签列表就可以清晰地标识出哪些产品被抽取为样本（标记为 1），哪些未被抽取（标记为 0），方便后续依据标签抽取样本。
**抽样后验证与记录**
		对抽取的样本再次核对其是否符合各层的抽样数量要求以及是否准确涵盖了相应产品，确保抽样过程无遗漏、无错误。
		- 详细记录整个抽样过程，包括总体情况、分层依据、各层抽样数量确定过程、随机数生成方式以及最终抽取的样本编号、对应的抽样标签列表等信息，方便后续追溯以及对抽样结果进行分析解读时参考。

]

最后产出

输出到/Users/didi/Downloads/panth/tag_ct/overlap/07_随机抽样

新建一个文件夹,用 yymmddhhmm 来命名
产出文件:
1.抽样结果表_yymmddhhmm
需求:返回 A 表的全部字段,增加is_overlap_c,是否随机抽样
2.抽样逻辑中间表_yymmddhhmm
_yymmddhhmm是动态的时间戳

中间表是随机 PROMPT 的工作过程表

最后,请先理解我的需求并简洁阐述需求(关键且不遗漏),跟我确认,我回复开始,你就开始写 Python 代码