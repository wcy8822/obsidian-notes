完全理解你的节奏与诉求。把链路再压成一张“**可跑的分节点总控图**”，先锁**大逻辑**，随后每个节点各出一份可直接跑的 Python 入口（分批跑，串起来就是系统）。

# 一、全链路总纲（只对逻辑）

**目标图**（左→右）
`多源输入 → RAW1（只采） → RAW2（预清洗统一口径） → Tall（真相层） → Hot（宽层） → QA（监控） → Snapshot/Replay（回放）`

* **统一主键**：`store_id`；**统一业务键**：`tag_code`；**不改三表**（只读）。
* **三槽单槽**：由 `tag_spec.value_type` 决定唯一槽；`enum` 统一以 **string 槽**存 `enum_code`。
* **状态与证据**：`evidence_state` 字典已锁，`conf` 几何加权口径 A 已锁，`reason_code/text` 结构化。
* **策略来自配置**：`ttl.yaml`、`merge_policy.yaml`、`metrics.yaml`（你本地校验已通过）。
* **分治运行**：每个节点都能单独执行与复跑；节点间通过**文件接口契约**衔接。

---

# 二、分节点“接口契约”（跑什么、入参出参、验收线）

## 节点 N0｜源汇聚（入仓前准备）— *可选预处理*

* **输入**：N 个来源表（异构列名）。
* **输出**：按 `conf/mappings/sources.yaml` 规范化的**抽取视图**（仅列映射，不改语义），供 N1 使用。
* **验收**：抽取视图至少包含 `store_id/tag_code/source/observed_at` 四列；其余列随源。
* **状态**：**建议使用**（已给模板 sources.yaml & raw1\_fill.yaml 的口径）。

## 节点 N1｜RAW1（只采）

* **输入**：N0 抽取视图（或直接用原始表）。
* **算法口径**：只做“**语法级补齐**”（trim/半角/布尔真值解析/记录 `upload_batch_id`/`origin_cols`）。
* **输出**：`data/raw/sample/sample_raw1.csv`（或你指定路径），**列契约**：
  `store_id, tag_code, raw_value_text, raw_value_code, source, observed_at, upload_batch_id, origin_cols`
* **验收**：1) 四个关键列非空；2) 其余列允许空；3) 批次号与来源列来源可追溯。
* **状态**：**口径已锁**（你已同意“实用模式 P”）。

## 节点 N2｜RAW2（预清洗统一口径）

* **输入**：RAW1 + 三表 + 策略配置（ttl/merge）。
* **算法口径**：

  * 依据 `tag_spec.value_type` 激活单槽；
  * 值域检查（`bool/enum` 对 `tag_enum`），`regex` 校验（若 spec 提供）；
  * 产出 `evidence_state / reason_code / reason_text / conf / ttl_days`；
  * 仅做**口径对齐与合法性判定**，**不做多源冲突解**。
* **输出**：`data/raw/sample/sample_raw2.csv`（或分区输出），**列契约**：
  `store_id, as_of_date, tag_code, target_value_bool, target_value_number, target_value_string, source, evidence_state, ttl_days, reason_code, reason_text, conf, upload_batch_id`
* **验收**：1) 三槽互斥；2) 证据位齐全；3) `ttl_days` 来自配置且 >0；4) 违规值进入对应 `evidence_state`。
* **状态**：**口径已锁**。

## 节点 N3｜Tall（真相层：多源融合 + 择优）

* **输入**：RAW2（可能多来源多条）+ `merge_policy.yaml`。
* **算法口径**（已锁）：

  * 过滤致命态（`MISSING/SOURCE_BLACKLISTED/OUT_OF_ENUM/REGEX_FAIL`）；
  * 计算 `C_*` 组件分与 `conf`；
  * **tie-break**：`conf`↓ → `observed_at`↓ → `C_source`↓ → 白名单胜 → 源字典序；
  * 无合法候选 → `fallback`（侧写 `used_fallback=1`）。
* **输出**：`output/tall/tall_{YYYYMMDD}_{HHMM}.csv`，**列契约**：
  `store_id, tag_code, snapshot_date, target_value_bool, target_value_number, target_value_string, spec_version, calc_type, value_source, used_fallback, used_enum_code, evidence_state, reason_code, reason_text, conf, ttl_days, source`
* **验收**：1) 每 `store_id+tag_code` 当日唯一一行；2) 侧写位齐全可追溯；3) `enum` 值为 `enum_code`。
* **状态**：**口径已锁**。

## 节点 N4｜Hot（宽层）

* **输入**：Tall + `tag_enum`（取展示名）。
* **算法口径**：按 P0 清单透视；展示名 **联表取，不落事实**。
* **输出**：`output/hot/hot_{YYYYMMDD}_{HHMM}.csv`，**列契约**：
  `store_id, snapshot_date, <13列标签横展>`
* **验收**：1) 宽表主键 `store_id+snapshot_date`；2) `open_24h ↔ open_hours` 一致性通过 QA。
* **状态**：**口径已锁**。

## 节点 N5｜QA（质量监控）

* **输入**：三表 + RAW2/Tall/Hot。
* **算法口径**：结构不变式、域外值、兜底率、新鲜度、变更率；反向校验（已含 `open_24h` 对 `open_hours`）。
* **输出**：`output/qa/qa_{YYYYMMDD}_{HHMM}.json`
* **验收**：`metrics.yaml` 阈值全绿或按告警级别出报告。
* **状态**：**口径已锁**。

## 节点 N6｜Snapshot/Replay（地标快照与回放）

* **输入/输出**：`logs/snapshots/snap_{YYYYMMDD}_{HHMM}/`（策略+三表+必要中间件）。
* **口径**：按 manifest 切换来源或运行参数覆盖；重放可复现上次批次。
* **状态**：**口径已锁**。

---

# 三、从“逻辑”到“能跑”的编码落盘计划（分批可跑）

> 每个节点一个独立入口，先做**骨架跑通**，再逐步提高“语义完成度”。都放 `scripts/`，并写死输入输出契约（列名/路径）。

| 节点      | 入口脚本（建议名）                            | 必读配置                                                                   | 输入 → 输出                  | 最小可跑目标（MVP）                                |
| ------- | ------------------------------------ | ---------------------------------------------------------------------- | ------------------------ | ------------------------------------------ |
| N1 RAW1 | `raw1_build.py`                      | `mappings/sources.yaml`, `policies/raw1_fill.yaml`                     | N 源 → `sample_raw1.csv`  | 抽取优先列、布尔解析、补 `upload_batch_id/origin_cols` |
| N2 RAW2 | `raw2_clean.py`                      | `contracts/tag_spec.csv`, `data/ref/tag_enum.csv`, `policies/ttl.yaml` | RAW1 → `sample_raw2.csv` | 三槽激活、值域/regex 校验、证据位/ttl/conf              |
| N3 Tall | `tall_merge.py`                      | `policies/merge_policy.yaml`                                           | RAW2 → Tall CSV          | 评分、tie-break、fallback 侧写                   |
| N4 Hot  | `hot_wide.py`                        | `fusion/hot_wide.yaml`                                                 | Tall → Hot CSV           | 13 列横展 + 展示名 join                          |
| N5 QA   | `qa_report.py`                       | `qa/metrics.yaml`                                                      | 三表+Tall/RAW2 → QA JSON   | 各指标与反向校验                                   |
| N6 Snap | `snapshot_save.py` / `replay_run.py` | manifest + include\_patterns                                           | 复制/回放                    | 生成 `snap_*` 并可重放上一批                        |

**统一命令风格**（例）：

```bash
python scripts/raw1_build.py   --root . --manifest conf/manifest.yaml --date 2025-09-20
python scripts/raw2_clean.py   --root . --manifest conf/manifest.yaml --date 2025-09-20
python scripts/tall_merge.py   --root . --manifest conf/manifest.yaml --date 2025-09-20
python scripts/hot_wide.py     --root . --manifest conf/manifest.yaml --date 2025-09-20
python scripts/qa_report.py    --root . --manifest conf/manifest.yaml --date 2025-09-20
python scripts/snapshot_save.py --root . --manifest conf/manifest.yaml --date 2025-09-20
```

---

# 四、系统封装思路（节点 = 模块；模块集合 = 系统）

* **模块化接口**：每个脚本只关心自己的“输入契约/输出契约”，上游输出就是下游输入。
* **幂等**：相同 `--date/--batch_id` 重跑覆盖同名文件，保证可复现。
* **配置驱动**：代码只读 `conf/**.yaml`，不写死业务逻辑；调参=改 YAML。
* **可分批执行**：随时在 N1/N2/N3 任意节点停下检查结果，再继续。
* **系统化包装**：后续可加一个 `runner.py` 或 `Makefile`：

  * `make raw1` → 跑 N1
  * `make raw2` → 跑 N1+N2
  * `make full` → 一键 N1→N6

---

# 五、当前状态 & 下一拍

* **逻辑侧**：六节点口径全部**已确认**；三表/配置/清洗框架 Canvas 都**已锁定**。
* **工程侧**：你已完成配置校验通过；缺少的是**分节点入口脚本**（按上表 6 个）。
* **建议下一步**（继续贴合你的工作流）：

  1. 我先给出 **N1/N2 两个脚本的“可运行骨架版”**（读取你现有 manifest 与 YAML，严格按契约输出空跑/样例）。
  2. 你把 10–20 行样例源数据放到 `data/raw/sample/`；
  3. 跑 N1→N2，产出 `sample_raw1.csv / sample_raw2.csv`；
  4. 再接 N3→N5，把 Tall/Hot/QA 跑出来验证阈值与反向校验。

当这 6 个节点都能在你机子上按命令跑通，就从“口径对齐”自然升级为“**自动化清洗系统**”。接下来你要我先产 **N1+N2 的骨架代码**，我就直接给可跑版本；再逐个节点把系统拼齐。
