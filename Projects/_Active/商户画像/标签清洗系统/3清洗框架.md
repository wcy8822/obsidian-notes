# 商户画像｜清洗框架（仅逻辑｜v1.1｜2025-09-19）

> 约定：本页 **不涉及任何代码**，仅做“逻辑对齐与口径共识”。对齐即固化；未对齐保持显式“待对齐”状态。
> 关联：三表说明与共识已单独锁定在《三表使用说明 & 共识记录（v1.0）》中，本页不再重复。

---

## 0. 摘要视图（随迭代更新）

* **整体逻辑框架**：多源输入 → RAW1（只采）→ RAW2（预清洗统一输入）→ Tall（真相层）→ Hot（宽层）→ QA/回放。
* **现在的进度**：

  * ✅ 已确认：

    * 唯一维度主键 **store\_id**（历史 station\_id 全量替换）；地理维度不上线；
    * 仅用 **tag\_code** 关联；
    * 三表治理合规（主键/子集/默认唯一）与分目录读取；
    * P0 13 标签清单；
    * `spec.calc_type` 分流（result/compute）与 `spec.fallback` 兜底（Tall 侧写 `used_fallback`）；
    * 事实层只存 **code**，展示名在 Hot 联接 `tag_enum`；
    * **RAW1/RAW2 三槽模型**：`value_type→单槽激活`（enum 统一 **string 存 enum\_code**）；
    * 多源**算法底座 + 预置权重**（conservative/balanced/aggressive），可配置覆盖；
    * `evidence_state` 字典与优先级（含 `SOURCE_BLACKLISTED/TTL_NOT_SET`）；
    * 置信度 `conf`＝几何加权（`C_source·C_fresh·C_rule·C_match`，口径A：fallback 通过 `C_rule=0.5` 自然降分）；
    * `ttl_days`：**按 tag\_code 配置**（可细化到 tag+source）。
  * 🔄 进行中：

    * P0 13 标签的 **fields 语义清单**（逐 tag 列口径，不写代码）。
  * ❗待对齐：无（本页其余均已口径化）。

---

## 1. 目标与边界(确认)

* **目标**：在不改变现网列名/结构的前提下，完成 P0 13 标签的可复现清洗路径，形成可回放、可监控的真相层（Tall）与消费层（Hot）。
* **边界**：

  * 本页不落代码，仅共识“定义与原则”；
  * 维度统一为 `store_id`，不引入市/省等维度；
  * 三表作为**治理基准**，事实值域与口径以其为准；
  * 仅以 `tag_code` 关联，不引入 `tag_id`。

---

## 2. 数据流程（(确认)）

> 命名澄清：统一术语为 **字段口径对齐（map）**，不再使用易歧义的“rename”。层间关联**一律**用 `store_id + tag_code`（到 Hot 为止）；治理三表与事实通过 `tag_code` 联接。

### 2.1 全链路契约（Layer→Layer 的关联与产出）(确认)

* **治理基准（三表）**：`tag_catalog/tag_spec/tag_enum` —— 提供 `tag_code` 定义、值域与默认口径；**不是事实表**。
* **RAW1（摄取）→ RAW2（预清洗/统一输入）**：RAW1 只采不判；RAW2 在不改业务语义前提下做标准口径对齐（map）与轻清洗，形成**下游唯一输入**。
* **RAW2 → Tall（真相层）**：聚合为“每店×每标签×每日”的唯一事实，并落证据侧写。
* **Tall → Hot（宽层）**：按 P0 标签横向展开；展示名通过 `tag_enum` 联接获取；不把展示名写回事实。

### 2.2 表字典（逐层定义与字段解释）

#### A) RAW1（原始摄取，不改语义）(确认)

* **主键**：`store_id, tag_code, source, observed_at`
* **必备列**：`store_id, tag_code, raw_value_text, raw_value_code?, source, observed_at, upload_batch_id, origin_cols?`
* **作用**：**有什么就抓什么**；关键列齐全即可；不判断不修正。

#### B) RAW2（预清洗/标准口径对齐的统一输入）（已确认）

* **主键**：`store_id, tag_code, as_of_date, source`
* **必备列**：
  `store_id, as_of_date, tag_code, target_value_bool, target_value_number, target_value_string, source, evidence_state, ttl_days, reason_code, reason_text, conf, upload_batch_id`
* **关键规则**：

  * **单槽原则**：三槽互斥，由 `tag_spec.value_type` 决定唯一激活槽；其余为 NULL；
  * **值域合规**：`bool/enum` 必须命中布尔真值集/`tag_enum`；
  * **不改语义**：仅做口径对齐（map）与轻清洗（trim/全半角/大小写比较）；
  * **上游驱动**：槽位激活/默认兜底/calc\_type/spec\_version 均由三表决定。

##### RAW2 · 证据态口径（已确认）

* **字段**：`evidence_state`（enum）
* **取值集**：`OK / OUT_OF_ENUM / REGEX_FAIL / FALLBACK_APPLIED / CONFLICT / TIMEOUT / EXPIRED / MISSING / SOURCE_BLACKLISTED / TTL_NOT_SET`
* **优先级**：`MISSING > SOURCE_BLACKLISTED > OUT_OF_ENUM > REGEX_FAIL > CONFLICT > TIMEOUT > TTL_NOT_SET > EXPIRED > FALLBACK_APPLIED > OK`。

##### RAW2 · 取值原因口径（已确认）

* **字段**：`reason_code`（枚举）、`reason_text`（短句）
* **`reason_code` 值域**：`HIT_ENUM / USED_FALLBACK / CONFLICT_TIEBREAK / REGEX_FAIL / OUT_OF_ENUM / SOURCE_BLACKLISTED / EXPIRED / TTL_NOT_SET / TIMEOUT / MISSING / OTHER`
* **模版示例**：`hit enum=SMALL via alias score=0.92 method=fuzzy`；`fallback applied={other} because=OUT_OF_ENUM`；

##### RAW2 · 置信度口径（已确认｜口径A）

* **组件**：`C_source`（来源权重）·`C_fresh`（新鲜度衰减）·`C_rule`（规则完整度：regex=1.0、fallback=0.5、invalid=0.0）·`C_match`（匹配得分/结果型=1）
* **合成**：几何加权 `conf = C_source^w1 × C_fresh^w2 × C_rule^w3 × C_match^w4`（默认 balanced：0.4/0.3/0.1/0.2，可覆盖）。
* **特殊状态**：致命态（`OUT_OF_ENUM/REGEX_FAIL/MISSING/SOURCE_BLACKLISTED`）→ `conf=0`；`TTL_NOT_SET` 不改分，仅标记；`EXPIRED` 随 `C_fresh` 自然衰减。

##### 三槽激活规则（严格口径｜已确认）

* 映射：`value_type` → 槽位

  * `bool` → `target_value_bool`（0/1，保留 99/NULL 占位）
  * `enum` → **`target_value_string` 存 `enum_code`**（统一，不开放数码枚举例外）
  * `id|string` → `target_value_string`
* 其余槽位一律 NULL；禁止跨槽混用。

#### C) Tall（真相层）（已确认）

* **主键**：`store_id, tag_code, snapshot_date`
* **必备列**：`store_id, tag_code, snapshot_date, target_value_bool, target_value_number, target_value_string, spec_version, calc_type, value_source, used_fallback, used_enum_code, evidence_state?, reason_code?, reason_text?, conf?, ttl_days?, source?`
* **作用**：每日唯一事实 + 证据侧写；供 Hot 与监控使用。

#### D) Hot（宽层）（已确认）

* **主键**：`store_id, snapshot_date`
* **列**：P0 13 标签横向展开；展示名联接 `tag_enum` 获取；不把展示名写入事实列。

#### E) 治理表（只读）（已确认）

* `tag_catalog` / `tag_spec` / `tag_enum` —— 仅提供口径与值域，不产事实。

### 2.3 关联与组件（已确认）

* **治理**：`tag_code` 的字典与口径；
* **RAW1** ——\[口径对齐/轻清洗]→ **RAW2** ——\[算法择优/冲突解]→ **Tall** ——\[透视/枚举联接]→ **Hot**；
* 关联键始终为：`store_id + tag_code`（到 Hot 为止）。

### 2.4 上下游可追溯性审计（已确认）

* **三表可推导**：`tag_code`、激活槽位、值域合法性、`fallback`、`calc_type`、`spec_version`。

* **运行态可计算**：`evidence_state / reason_code+reason_text / conf / value_source / used_fallback / used_enum_code`；

* **策略来源**：`ttl_days` 由 `conf/policies/ttl.yaml` 提供（优先级：by\_tag\_source ＞ by\_tag ＞ default）。
  关联与组件（一图胜千言｜文字版）

* **治理**：提供 `tag_code` 的“字典与口径”，不产事实。

* **RAW1（多源摄取）** ——\[口径对齐 map/轻清洗]→ **RAW2（统一输入）** ——\[优先级/冲突解]→ **Tall（单一事实）** ——\[透视/枚举联接]→ **Hot（消费宽表）**。

* 关联键**始终**为：`store_id + tag_code`（到 Hot 为止）；治理三表与事实类通过 `tag_code` 联接。

### 2.4 上下游可追溯性审计（你关心的“是否想当然”）

> 目的：标注**哪些字段完全由三表可推导**，哪些属于**运行态生成**（需你确认）。

**可由上游三表直接决定/推导**

* `tag_code`（catalog/spec/enum）
* 激活槽位：由 `tag_spec.value_type` 决定 `target_value_*` 三选一（单槽原则）
* 值域合法性：`bool/enum` 由 `tag_enum`/布尔真值集校验
* `fallback`：来自 `tag_spec.fallback`
* `calc_type`：来自 `tag_spec.calc_type`
* `spec_version`：来自 `tag_spec.spec_version`

**运行态生成（非三表直接给出，需确认口径）**（**口径建议见下**）我只关心,这个口径都是可以通过代码计算出来嘛?假设上游无法给出你预期字段的具体值,能给的只有 RAW1 的数据源

* `evidence_state`：证据态（建议：`OK/OUT_OF_ENUM/REGEX_FAIL/FALLBACK_APPLIED/CONFLICT/TIMEOUT/EXPIRED` 等枚举）
* `reason`：人类可读的解释串（如“命中枚举 SMALL（score=0.92）”；“域外值→fallback=other”）
* `conf`：置信度（来源于匹配/融合得分或来源可信度）
* `ttl_days`：有效期（可来自 `tag_spec` 未来扩展字段，当前为策略常量或按标签字典配置）
* `value_source`/`used_fallback`/`used_enum_code`：证据侧写（为可回溯而生，不改变事实值）
* `source/observed_at/upload_batch_id`：来自上游数据流的运行信息

---

## 3. 标签分型与执行策略（已确认）

### 3.1 通用**证据五件套**（result & compute 通用）

1. 来源链路：`source, observed_at, upload_batch_id`
2. 口径版本：`spec_version, calc_type`
3. 取值证明：`used_enum_code`（或 bool 真值证明 / string 原文）
4. 回退痕迹：`used_fallback`（0/1）+ `fallback`
5. 状态判定：`evidence_state`

### 3.2 计算型**额外六件套**（不与上面重叠）

6. 归一规则名：`alias_norm_rule`
7. 匹配方法：`match_method`（exact/contains/fuzzy/score）
8. 阈值：`match_score_threshold`
9. 白/黑名单命中：`white_list_hit / black_list_hit`
10. 候选数与最高分：`candidate_count / best_score`
11. 冲突解轨迹：`tie_break_trace`

> 结果型 = 通用五件套；计算型 = 通用五件套 + 额外六件套。均落在 RAW2→Tall 侧写字段中，便于审计与回放。

---

## 4. QA 指标与阈值（已确认）

**结构不变式**：PK 唯一、子集关系、默认唯一。

**质量指标**：覆盖率 / 域外值率 / 兜底率 / 新鲜度。

**批次对比指标**：

* `tall_records_total`、`tall_records_changed`、`changed_rate`
* 按 `tag_code` 的 `changed/unchanged` 与 `reason_dist`
* 反向校验：如 `open_24h=1` ↔ `open_hours` 覆盖 00:00–24:00

**阈值配置**：`conf/qa/metrics.yaml`（warn/error）。

---

## 5. 多源优先级与冲突解（已确认）

**算法骨架**（统一）

1. 合法性过滤：丢弃 `evidence_state ∈ {MISSING, SOURCE_BLACKLISTED, OUT_OF_ENUM, REGEX_FAIL}`；
2. 组件得分：`C_source, C_fresh, C_rule, C_match` ∈ \[0,1]；
3. 几何加权：`conf = C_source^w1 × C_fresh^w2 × C_rule^w3 × C_match^w4`；
4. 选择 Top1；tie-break 顺序：`conf`↓ → `observed_at`↓ → `C_source`↓ → `source in whitelist` → `source` 字典序↑；
5. 无合法候选 → 使用 `spec.fallback`（`evidence_state=FALLBACK_APPLIED`）。

**预置权重**（可配置；默认 balanced）

* conservative：`{0.60, 0.25, 0.05, 0.10}`
* balanced：`{0.40, 0.30, 0.10, 0.20}`
* aggressive：`{0.25, 0.50, 0.05, 0.20}`

**配置位置**：`conf/policies/merge_policy.yaml`（支持按 tag / tag+source 覆盖、来源黑白名单、freshness 衰减口径）。

---

## 6. 命名与分区（已确认）

* **批次 ID**：`batch_id = YYYYMMDD_HHMM`（Asia/Tokyo）
* **Tall**：`tall_{YYYYMMDD}_{HHMM}.csv`
* **Hot**： `hot_{YYYYMMDD}_{HHMM}.csv`
* **QA 报告**：`qa_{YYYYMMDD}_{HHMM}.json`
* **快照目录**：`logs/snapshots/snap_{YYYYMMDD}_{HHMM}/` 原样拷贝三表与策略文件

回放：manifest 指向对应 `snap_*` 目录或运行参数覆盖。

---

## 7. 风险与后手（加强版｜已确认）

**监控触发**：

* `OUT_OF_ENUM` 比例 > 阈值；
* `FALLBACK_APPLIED` 占比异常上升；
* `changed_rate` 超上限；
* 新鲜度异常（RAW1 `observed_at` / 三表 mtime 滞后）；
* 反向校验失败（`open_24h` ↔ `open_hours`）。

**响应分级**：

* `warn`：标记批次观察；
* `error`：启用降级策略（切换 Conservative 或锁定 `raw > enum > fallback`）；
* `critical`：自动回滚上一快照 + 输出修复 TODO（附 TopN 影响门店/标签）。

**灰度/金丝雀**：

* 批次先跑 5% `store_id` 子集，指标通过再全量；失败自动回滚。

---

## 8. P0 13 标签 fields 语义清单（已确认）

> 统一遵循通用口径：三槽单槽原则；enum 用 string 槽存 enum\_code；fallback 以 tag\_spec 为准；regex 仅在存在时启用；多源合并默认 balanced，可按 tag 覆盖；ttl\_days 来自 ttl.yaml（by\_tag\_source ＞ by\_tag ＞ default）。

* brand\_name｜value\_type=enum｜calc\_type=compute｜槽位：target\_value\_string(enum\_code)｜fallback=other｜regex：无｜证据：通用五件套 + 计算型六件套（别名归一/阈值/白黑名单/候选/轨迹）。
* brand\_level｜enum｜compute｜槽：string(enum\_code)｜fallback=SMALL｜regex：无｜证据：通用+计算型六件套。
* competitive\_overlap｜bool｜result｜槽：bool（0/1/99）｜fallback=99｜regex：无｜证据：通用五件套。
* sme\_supplier\_partner｜bool｜result｜槽：bool｜fallback=99｜regex：无｜证据：通用五件套。
* sme\_supplier｜id｜result｜槽：string（保留原始 id）｜fallback=unknown｜regex：可选（若上线）｜证据：通用五件套。
* wyc\_pricing\_enabled｜bool｜compute｜槽：bool｜fallback=99｜regex：无｜证据：通用五件套 + 计算型六件套（若涉及规则判定则记录 match\_method/threshold 等）。
* service\_carwash\_available｜bool｜result｜槽：bool｜fallback=99｜regex：无｜证据：通用五件套。
* service\_carwash\_type｜enum｜result｜槽：string(enum\_code)｜fallback=none｜regex：无｜证据：通用五件套。
* convenience\_store\_available｜bool｜result｜槽：bool｜fallback=99｜regex：无｜证据：通用五件套。
* restroom\_available｜bool｜result｜槽：bool｜fallback=99｜regex：无｜证据：通用五件套。
* parking\_available｜bool｜result｜槽：bool｜fallback=99｜regex：无｜证据：通用五件套。
* open\_24h｜bool｜result｜槽：bool｜fallback=99｜regex：无｜反向校验：若值=1，应与 open\_hours 覆盖全天一致｜证据：通用五件套。
* open\_hours｜string｜result｜槽：string｜fallback=unknown｜regex：HH\:MM-HH\:MM 或多段（以分号分隔）；与 open\_24h 做一致性反查。

---

## 9. 主线状态（已闭环）

* 清洗框架口径：**已锁定**。
* 配置专册（TTL/合并策略/QA）：**已锁定**。
* P0 13 标签 fields 语义清单：**已锁定**。

> 后续仅做轻量变更（如补充 regex 或阈值），不改主干口径。
