喜欢这个大胆！我建议把它切成“两根试飞箭”：

* **箭①：`competitive_overlap` 全量直跑**（结果型，先把“全量跑、出证据”这条线打通）
* **箭②：`brand_name` + `brand_level` 深挖清洗链路**（计算型，验证别名归一/阈值/白黑名单/置信度与回放）

这样既能立刻拿到“全量可证明”的业务结果，也能把最复杂的计算型口径在一对母子标签里跑到位。

---

# 箭①：`competitive_overlap`（全量直跑 + 举证）

**定位**：`bool` + `result`，你线下已做空间/规则判定，只要把“结论+证据”丢给我们系统。

**你要准备（按 RAW1 表头即可）：**

* `store_id, tag_code=competitive_overlap`
* `raw_value_code`：`0/1`（或 `raw_value_text`：`YES/NO`）
* `source`：比如 `overlap_calc`（线下产物别名）
* `observed_at`：ISO 时间
* `origin_cols`：建议附上你线下判定的关键证据（JSON），如 `{"competitors":["SINOPEC","CNPC"],"radius_m":300}`

**配置建议：**

* `ttl.yaml`：给 `competitive_overlap` 一个 **更短 TTL**（如 `7` 天），避免陈旧结论残留。
* `merge_policy.yaml/sources.weights`：为 `overlap_calc` 设高权重（如 `0.9`）。
* 如需多源并存（例如外部商情源也给过这个标签）：不用改代码，策略会自动择优；黑名单源可直接拉黑。

**跑法（全量/抽样都行）：**

```bash
# 将你线下全量结果拼成 RAW1 追加到 data/raw/sample/sample_raw1.csv（不改表头）
make raw2      # 预清洗：激活 bool 槽、状态/ttl/conf
make tall      # 多源择优：基本会直接选 overlap_calc
make hot       # 宽表：可见 competitive_overlap 列
make qa        # 看 out_of_enum_rate / fallback_rate / changed_rate / freshness_lag_h
```

**举证位（RAW2/Tall 都会落）：**

* `evidence_state`（OK/EXPIRED/…）
* `reason_code/text`（建议把你的“半径/匹配到的对手列表”写进 `reason_text`）
* `conf`（结果型通常接近 1；过期/黑名单/回退会降）

**验收口径：**

* 覆盖率 ≥ 95%（你线下已算过的一定要落进系统）
* `fallback_rate` ≈ 0（结果型不应大量兜底）
* 新鲜度 `freshness_lag_h < warn`（按 `metrics.yaml`）

---

# 箭②：`brand_name` + `brand_level`（计算型链路的“标靶组合”）

**定位**：

* `brand_name`：`enum + compute`（别名归一/关键词/白黑名单/阈值）
* `brand_level`：`enum + compute`（由 `brand_name` 或独立线索推断，层级如 `SMALL/MID/LARGE` 等）

**RAW1 最低要求：**

* `brand_name`：任意源能给出 `品牌原文` 或 `品牌码` 即可；都没有也行（RAW2 会标 `MISSING`）
* `brand_level`：没有直给就留空，交给计算；若个别源直给层级码，可放 `raw_value_code`

**三表准备（由我们已锁定口径驱动）：**

* `tag_enum.csv`：为 `brand_name` 维护好 `enum_code/enum_label/brand_aliases/keywords/white_list/black_list/alias_norm_rule/match_method/match_score_threshold`
* `tag_spec.csv`：`fallback=other`（brand\_name），`fallback=SMALL`（brand\_level）
* 这俩你已经齐了；后面只要随着训练更新别名/白黑名单即可。

**配置点：**

* `merge_policy.yaml/overrides.by_tag.brand_name`：已给出 **更敏感的 freshness** 与 **权重**（匹配分 `C_match` 更重要）
* 可以在 `by_tag_source` 对某些“高质量品牌源”单独升权

**链路要落的“计算型六件套”（证据侧写）：**

* `alias_norm_rule`、`match_method`、`match_score_threshold`
* `white_list_hit / black_list_hit`
* 候选与打分：`candidate_count / best_score`
* `tie_break_trace`（如果多候选同分，记录决策链）

**跑法：**

```bash
# 往 RAW1 追加 brand 相关原始字段（brand/brand_text/brand_code 等）
make raw2      # RAW2：别名归一、打分、regex（若有）→ evidence_state / conf / ttl
make tall      # 多源择优 + fallback=other/SMALL 的侧写
make hot
make qa        # 看 out_of_enum_rate / fallback_rate；特别关注 brand 的 OUT_OF_ENUM
```

**验收口径：**

* `brand_name` OUT\_OF\_ENUM ≤ 阈值（优先修 enum 的别名/keywords）
* `brand_level` 的 `used_fallback` 比例在可接受范围（若高→需要补推断规则或来源）
* `changed_rate` 在首次上线后趋稳；明显跳变要能追溯 `overrides/别名更新/黑名单变更`

---

## 组合打法建议（先快后深）

1. **第一周：箭①先落地**

   * 只动 `competitive_overlap` 全量，拿到**可复现的证据化结果**与 QA 报告 → 给业务展示“系统可跑且可审计”。
2. **并行启动箭②**

   * 从 2–3 个高频源补 `sources.yaml` 的 `brand_name/open_24h/open_hours` 的 `prefer_cols`；
   * 跑 `brand_name` 的归一，快速校准 `brand_aliases/keywords/阈值`；
   * 由 `brand_name → brand_level`（如果 `brand_level` 可由品牌分类映射得到，先用映射；否则先兜底 `SMALL`，再逐步加规则）。

---

## 风险 & 预案

* **源字段飘**：`sources.yaml` 命中率太低 → 在 QA 报告里加“RAW1 非空率 by source/tag”面板，快速补 `prefer_cols`。
* **品牌别名噪声**：`OUT_OF_ENUM` 偏高/多品牌同分 → 提升 `match_score_threshold`，或启用/更新 `white_list/black_list`。
* **全量吞吐**：一次性全量很大 → 先跑“分批（按日期）+ 基线快照”，逐批 merge；我们的 `snapshot` 能保证回放对齐。

---

## 一键小清单（今天就能做）

```bash
# 1) 先把 competitive_overlap 全量/抽样写入 RAW1（保持表头）
make raw2 && make tall && make hot && make qa

# 2) 往 RAW1 追加品牌相关原文列（brand/brand_text/brand_code），完善 sources.yaml 的 prefer_cols
make raw2 && make tall && make hot && make qa

# 3) 生成一次快照，固化策略与三表，为后续回放做基线
make snapshot
```

如果你愿意，我可以马上给出\*\*`competitive_overlap` 的 RAW2→Tall“严格口径版”\*\*（包含致命态过滤、TTL、conf、tie-break），以及 **`brand_name` 的匹配打分样例**（候选生成 + 阈值裁决 + 侧写位示例）。这两段一上，你就能把两支箭直接射出去。
