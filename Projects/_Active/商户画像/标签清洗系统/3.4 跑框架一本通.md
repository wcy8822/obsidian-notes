可以一起跑“箭① + 箭②”。先把**大框架 1→5 步**锁定，再把每一步拆为可执行的小步骤和你这边要做的动作。跑通这两个标签后，按同样套路**平滑扩容新标签**（只改三表与映射，不动代码）。

---

# 大框架（1→5 步）— 先锁口径

**Step 1｜RAW1 汇聚（只采 + 语法规范）**

* **输入目录**：`data/raw/inbox/<批次>/<source_key>/*.csv`（S2=宽表；S3=长表）。
* **关键列**：`store_id, date_ob`（多格式日期可进；ID 有引号/全角/Excel 引号前缀都能被规范化）。
* **宽表列名**＝`tag_code`；**长表**列：`tag_code, enum_code, value_text`。
* **产出**：`runs/<批次>/raw1.csv` + `raw1_report.json`；`data/raw/sample/sample_raw1.csv`（给 RAW2）。

**Step 2｜RAW2 预清洗（语义守门）**

* 激活单槽：按 `tag_spec.value_type` 落 `target_value_*`；
* **bool/enum 强值域**：超域 → `OUT_OF_ENUM`；
* **regex 校验**：如 `open_hours` 不过正则 → `REGEX_FAIL`；
* 写证据：`evidence_state / ttl_days / reason_* / conf`。

**Step 3｜Tall 合并择优（真相层）**

* 汇总同 `(store_id, tag_code)` 的全部候选（S1/S2/S3…），按策略：
  `conf = C_source^w1 × C_fresh^w2 × C_rule^w3 × C_match^w4`，tie-break 固定序。
* 选一条**最佳合法**候选；无合法 → 用 `spec.fallback`（并记 `used_fallback=1`）。
* 结果侧写：`value_source / used_fallback / conf / evidence_state / reason_*`。

**Step 4｜Hot 宽层 + Snapshot**

* **Hot**：把 Tall 透视为 13 列宽表（消费用）。
* **快照**：`logs/snapshots/snap_{YYYYMMDD}/{tall.csv, hot.csv, configs...}`（供 Delta 与回放）。

**Step 5｜Delta 双产出（对比上一版）**

* 基线优先：`Tall(D-1)` → 外部 `S1` → 防呆（默认 suppress 首日洪峰）。
* 产出：`output/delta/tall_delta_{date}.csv`、`output/delta/hot_delta_{date}.csv`。
* 变更类型：`CREATED / UPDATED / EXPIRED / FALLBACK_ADDED / FALLBACK_REMOVED / STATE_CHANGED`。

---

# 小步骤与你的操作清单（每步 1→5 拆解）

## Step 1｜RAW1（你要做）

1. **投喂文件**（同批可混 S2/S3）：

   * S2 宽表示例列：`store_id,date_ob,competitive_overlap,brand_name,...`
   * S3 长表示例列：`store_id,date_ob,tag_code,enum_code,value_text`
2. **sources.yaml 映射检查**（确保命中）：

   * `s2.tags.competitive_overlap.prefer_cols: [competitive_overlap, overlap_flag]`
   * `s2.tags.brand_name.prefer_cols: [brand_name, brand_text]`
   * `s3.long.tag_code_col=value_tag_code`（你的列名若为 `tag_code` 就写 `tag_code`）
3. 运行：

   ```bash
   python scripts/run_ingest_raw1.py --root . --manifest conf/manifest.yaml \
     --batch_id 20250920_Arw12
   ```
4. 自检 `raw1_report.json`：`missing_id/obs=0`、`by_tag` 命中 > 0。

**箭①/② 特别点**

* `competitive_overlap`：文本 YES/NO 会被解析到 `raw_value_code=1/0`，原文保留。
* `brand_name`：多来源多别名不归一，进入 RAW2 再归一。

## Step 2｜RAW2（系统自动）

1. 运行：`make raw2`
2. 自检 `data/raw/sample/sample_raw2.csv`：

   * `competitive_overlap` 仅见 `0/1` 合法码；超域行带 `OUT_OF_ENUM`；
   * `brand_name` 生成候选品牌码与 `match_score`（由 `tag_enum.brand_aliases/keywords` 驱动）。

**建议**

* `tag_enum.csv` 为 `competitive_overlap` 写三行合法码：`1/0/99`（99 只兜底）。
* `brand_name` 的别名/关键词尽量先覆盖 80% 常见写法。

## Step 3｜Tall（系统自动）

1. 运行：`make tall`
2. 自检 `output/tall/tall_{date}.csv`：对同一 `(store, tag)` 仅一行；看：

   * `value_source`（来自哪一源）；
   * `used_fallback`（是否兜底）；
   * `conf`（是否夸张低）与 `evidence_state`（是否非 OK）。

**箭②延伸：brand\_level 的派生**

* `brand_name` 先定，再算 `brand_level`：

  * **KA**：`brand_name ∈ {中石化,中石油,中海油,中化,延长,BP,道达尔,壳牌,加德士}`
  * **CKA**：该品牌**有效合作站点数 ≥ 阈值**（建议阈值 10，来自 `Tall(D-1)` 的 groupby 计数）
  * 其他：`小散`
* 建议新增配置：`conf/policies/brand_level.yaml`：

  ```yaml
  ka_whitelist: ["中国石化","中国石油","中国海油","中国中化","延长石油","BP","道达尔","壳牌","加德士"]
  cka_threshold: 10
  count_by: prev_day_tall   # prev_day_tall | today_tall
  min_days_to_downgrade: 7  # 降级最小生效天数，避免抖动
  ```
* 计算顺序：先 KA 白名单；否则看计数阈值；落 `reason_text`（命中 KA / 计数=xx≥阈值）。

## Step 4｜Hot + Snapshot（系统自动）

* `make hot` → 宽表 13 列；
* `make snapshot` → 固化 `snap_{date}/tall.csv`（供明日 Delta 与基线）。

## Step 5｜Delta（你刚要的双产出）

* `make delta DATE=20250920`
* 自检：

  * `tall_delta_*` 里 `change_type` 只出 6 类；
  * 首日若无快照 → 默认 suppress（无大洪水）。

---

# 你要特别注意的细节与风险（运行前一眼看完）

* **枚举域覆盖**：

  * 箭①若出现大量 `OUT_OF_ENUM`，先补 `tag_enum` 而不是强行 fallback。
* **TTL 口径**：`competitive_overlap` 建议 `7` 天；品牌相关可长一些（`brand_name=90`）。TTL 长短会直接影响 Tall 的择优。
* **日期解析**：`date_ob` 缺失就用 mtime，`freshness` 会低；建议 S2/S3 尽量给时间列。
* **ID 清洗**：前导 `'`、全角、包裹引号都已在 RAW1 配置里加固；`missing_id` 不为 0 时别硬顶，先修源或放宽 `id_regex`。
* **brand\_name 抖动**：

  * 多源同分 Tie-break：我们已设 `source_whitelist` 和序列；
  * 仍抖 → 提升可信来源权重（`overrides.by_tag_source.brand_name.sX.weights`）或加白名单。
* **brand\_level 抖动**：

  * 由计数阈值导致：用 **D-1 计数** + `min_days_to_downgrade`（例如 7 天）平滑。
* **S1 缺席**：已用 **D-1 Tall** 作软基线；Delta 不会在首日爆全量（防呆已开）。

---

# 跑两个标签一起：最小执行剧本（你现在就能照做）

```bash
# 0) 目录一次性准备
mkdir -p data/raw/inbox output/{tall,hot,delta} logs/snapshots

# 1) 投喂本批（含箭①+箭②数据）
#   data/raw/inbox/20250920_Arw12/s2/*.csv   # 宽表：competitive_overlap, brand_name...
#   data/raw/inbox/20250920_Arw12/s3/*.csv   # 长表：store_id,date_ob,tag_code,enum_code,value_text

# 2) RAW1 → RAW2 → Tall → Hot → Snapshot
python scripts/run_ingest_raw1.py --root . --manifest conf/manifest.yaml --batch_id 20250920_Arw12
make raw2
make tall
make hot
make snapshot

# 3) Delta（相对 D-1 快照）
make delta DATE=20250920
```

**抽检点**

* `raw1_report.json`：`by_tag` 命中是否覆盖箭①/②；
* `sample_raw2.csv`：箭①仅 0/1 合法；箭②有 `match_score`；
* `tall_*.csv`：看 `value_source/used_fallback/conf`；
* `tall_delta_*.csv`：变更类型分布是否合理（首日通常为空或极少）。

---

# 扩容新标签时你只做两件事

1. 在 **sources.yaml** 给新 `tag_code` 配列（宽表 `prefer_cols`；长表自然带 `tag_code` 字段）；
2. 在 **tag\_spec/tag\_enum** 定义规格与枚举（必要时加 regex）。
   其余链路（RAW2/Tall/Hot/Delta/快照/QA）**无需改代码**，直接吃配置扩容。

---

如果这个“大框架 + 小步骤”你确认，我把“**箭①/箭② 联合跑批剧本**”加进 Canvas 的“运行手册”小节，并顺手给出两份**最小样例 CSV 的表头模板**（s2/s3 各一份），你只要复制列头、填几行数据就能演练一遍全链路。
