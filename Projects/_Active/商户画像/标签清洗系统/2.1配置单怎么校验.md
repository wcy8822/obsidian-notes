明白，直接给你三件事的干脆答案与落地方案。

## 1) 「配置单怎么校验」—给你一把能跑的校验器

我不能 100% 保证你本地的配置始终正确（因为可能被后续手改/复制时引入差错），但我给你一套**结构+引用+口径**三层校验脚本。你本地跑一条命令就能知道“OK / 具体哪儿不OK”。

**放置路径**：`/Users/didi/Downloads/panth/tag_ct_local/scripts/validate_configs.py`
**如何运行**：

```bash
# 建议先激活虚拟环境
cd /Users/didi/Downloads/panth/tag_ct_local
. .venv/bin/activate
python scripts/validate_configs.py --root . --manifest conf/manifest.yaml --strict
```

**它会检查：**

* YAML 结构：必填键是否齐全、类型是否正确（如 weights 是 dict、阈值是数字等）。
* 交叉引用：`ttl.yaml` 里的 `by_tag/*` 是否都在 `tag_catalog.csv` 的 `tag_code` 中；`merge_policy.yaml` 的 `overrides.*` 是否是合法 `tag_code`；`sources.*` 是否覆盖 RAW1 真实出现过的 `source` 值（可选警告）。
* 取值口径：

  * `ttl_days` 必须为正整数；
  * `evidence_state`/`reason_code` 取值是否在字典内（来自清洗框架已锁定口径）；
  * `merge_policy.presets.*.weights` 键名是否仅限 `C_source/C_fresh/C_rule/C_match` 且权重≥0；
  * `tie_break_order` 的取值是否在允许集合中；
  * QA 阈值 warn < error。
* 快照包含：`logs/snapshots/snap_YYYYMMDD_HHMM/` 是否纳入 `conf/policies/*.yaml` 和 `conf/qa/*.yaml`（保证回放可复现）。

**脚本（粘过去即可）**：

```python
# scripts/validate_configs.py
import argparse, csv, datetime as dt, json, re, sys, yaml
from pathlib import Path

ALLOWED_TIE_BREAK = ["conf_desc","observed_at_desc","C_source_desc","source_whitelist","source_lexi_asc"]
ALLOWED_EVIDENCE = {"OK","OUT_OF_ENUM","REGEX_FAIL","FALLBACK_APPLIED","CONFLICT",
                    "TIMEOUT","EXPIRED","MISSING","SOURCE_BLACKLISTED","TTL_NOT_SET"}
ALLOWED_REASON = {"HIT_ENUM","USED_FALLBACK","CONFLICT_TIEBREAK","REGEX_FAIL","OUT_OF_ENUM",
                  "SOURCE_BLACKLISTED","EXPIRED","TTL_NOT_SET","TIMEOUT","MISSING","OTHER"}

def load_yaml(p: Path):
    with p.open("r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {}

def load_csv_codes(p: Path, col="tag_code"):
    codes=set()
    with p.open("r", encoding="utf-8") as f:
        for i,row in enumerate(csv.DictReader(f)):
            if col not in row:
                raise ValueError(f"{p} 缺少列 {col}")
            codes.add(row[col].strip())
    if not codes:
        raise ValueError(f"{p} 没有数据")
    return codes

def fail(msg, bucket, out):
    out["errors"].append({"where":bucket,"msg":msg})

def warn(msg, bucket, out):
    out["warnings"].append({"where":bucket,"msg":msg})

def main():
    ap=argparse.ArgumentParser()
    ap.add_argument("--root", required=True)
    ap.add_argument("--manifest", default="conf/manifest.yaml")
    ap.add_argument("--strict", action="store_true")
    args=ap.parse_args()
    root=Path(args.root)
    out={"ok":True,"errors":[],"warnings":[],"summary":{}}

    # 读 manifest
    man = load_yaml(root / args.manifest)
    try:
        ttl_path = root / (man["policies"]["ttl"])
        merge_path = root / (man["policies"]["merge"])
        qa_path = root / (man["qa"]["metrics"])
    except Exception as e:
        fail(f"manifest 缺少必填键 policies/qa: {e}", "manifest", out); out["ok"]=False
        print(json.dumps(out,ensure_ascii=False,indent=2)); sys.exit(1)

    # 读三表（用于引用校验）
    catalog_p = root / "data/ref/tag_catalog.csv"
    spec_p = root / "conf/contracts/tag_spec.csv"  # 结构性使用
    enum_p = root / "data/ref/tag_enum.csv"
    try:
        tag_codes = load_csv_codes(catalog_p, "tag_code")
    except Exception as e:
        fail(f"读取 tag_catalog 失败: {e}", "catalog", out); out["ok"]=False; tag_codes=set()

    # 校验 ttl.yaml
    ttl = load_yaml(ttl_path)
    t = ttl.get("ttl", {})
    if "default_days" not in t:
        fail("ttl.default_days 缺失", "ttl.yaml", out)
    else:
        if not isinstance(t["default_days"], int) or t["default_days"]<=0:
            fail("ttl.default_days 必须为正整数", "ttl.yaml", out)
    for section in ("by_tag","by_tag_source"):
        sec = t.get(section) or {}
        if section=="by_tag":
            for k,v in sec.items():
                if k not in tag_codes:
                    fail(f"by_tag 中存在未知 tag_code: {k}", "ttl.yaml", out)
                if not isinstance(v,int) or v<=0:
                    fail(f"by_tag[{k}] 的天数必须为正整数", "ttl.yaml", out)
        else: # by_tag_source
            for tag, mp in sec.items():
                if tag not in tag_codes:
                    fail(f"by_tag_source 中未知 tag_code: {tag}", "ttl.yaml", out)
                if not isinstance(mp, dict) or not mp:
                    fail(f"by_tag_source[{tag}] 必须为非空映射", "ttl.yaml", out)
                for src,days in mp.items():
                    if not isinstance(days,int) or days<=0:
                        fail(f"by_tag_source[{tag}][{src}] 天数必须为正整数", "ttl.yaml", out)

    # 校验 merge_policy.yaml
    merge = load_yaml(merge_path)
    presets = (merge.get("presets") or {})
    for name in ("conservative","balanced","aggressive"):
        if name not in presets:
            fail(f"presets 缺少 {name}", "merge_policy.yaml", out)
        else:
            w = (presets[name] or {}).get("weights") or {}
            keys=set(w.keys())
            if keys != {"C_source","C_fresh","C_rule","C_match"}:
                fail(f"{name}.weights 键必须是 C_source/C_fresh/C_rule/C_match", "merge_policy.yaml", out)
            for k,v in w.items():
                if not isinstance(v,(int,float)) or v<0:
                    fail(f"{name}.weights.{k} 必须为非负数", "merge_policy.yaml", out)

    tie = (merge.get("functions") or {}).get("tie_break_order") or []
    for k in tie:
        if k not in ALLOWED_TIE_BREAK:
            fail(f"tie_break_order 包含非法项：{k}", "merge_policy.yaml", out)

    rule = (merge.get("functions") or {}).get("rule_completeness") or {}
    for k in ("regex_pass","fallback","invalid"):
        if k not in rule:
            fail(f"rule_completeness 缺少 {k}", "merge_policy.yaml", out)
    # overrides 的 tag 是否存在
    ov = merge.get("overrides") or {}
    for sec in ("by_tag","by_tag_source"):
        m = ov.get(sec) or {}
        for tag,_cfg in m.items():
            if tag not in tag_codes:
                fail(f"overrides.{sec} 含未知 tag_code: {tag}", "merge_policy.yaml", out)

    # 校验 qa/metrics.yaml
    qa = load_yaml(qa_path)
    thr = qa.get("thresholds") or {}
    def chk(pair, name):
        if "warn" not in pair or "error" not in pair:
            fail(f"{name} 缺少 warn/error", "qa/metrics.yaml", out)
        else:
            if not (isinstance(pair["warn"],(int,float)) and isinstance(pair["error"],(int,float))):
                fail(f"{name} warn/error 必须为数字", "qa/metrics.yaml", out)
            if pair["warn"]>=pair["error"]:
                fail(f"{name} warn 必须小于 error", "qa/metrics.yaml", out)
    for k,v in thr.items():
        chk(v, f"thresholds.{k}")

    # 报告
    if out["errors"]:
        out["ok"]=False
    out["summary"]={"ttl":str(ttl_path),"merge":str(merge_path),"qa":str(qa_path),
                    "tag_catalog":str(catalog_p),"errors":len(out["errors"]),"warnings":len(out["warnings"])}
    print(json.dumps(out, ensure_ascii=False, indent=2))
    sys.exit(0 if out["ok"] and not args.strict else (0 if out["ok"] else 2))

if __name__=="__main__":
    main()
```

**判定标准**：

* 返回 JSON 中 `ok=true` 且 `errors=[]` ⇒ 通过。
* `warnings` 可先不拦截产出，用于提示（例如某些 `source` 没设权重则回退默认 0.5）。

> 这样你**随时自检**；我这边也严格按同一口径写的。

---

## 2) Canvas 的状态文案

我刚把清洗框架的 Canvas 里所有“对焦中”的措辞，统一改成“**已确认/已锁定**”，并在顶部摘要与末尾“主线状态”两处标清“**已闭环**”。如果你还想把标题里的“对焦中”字样也去掉，我可以再新建一份“锁定版”副本（标题带 v1.0），当前内容不变，便于归档。

---

## 3) 接下来推进哪里？主线回顾 + 当前进度

**大主线（你定的）**：

1. 规范对齐（只读三表，锁主键与字段解释）✅
2. 清洗框架搭建（目录骨架+配置模板；结果型“择优+状态+不变式”，计算型“清洗/归一+融合”）✅
3. 跑批与 QA（最小样例跑出 Tall+Hot；覆盖率/新鲜度/稳定性/冲突预警报告）⬅️ **现在到这一步**
4. 基线与回放（固化 D-1 快照为“地标数据”；验证回放/回滚流程）▶️ 下一步

**当前已完成的产物**：

* 《三表使用说明 & 共识记录》：锁定。
* 《清洗框架（锁定版）》：RAW1/RAW2、三槽、证据件套、合并算法与预置、QA、回放命名全部锁定。
* 《配置清单（TTL/合并策略/QA）+ 参考加载代码》：锁定。
* P0 13 标签 **fields 语义清单**：锁定（你刚拍板：仅 brand\_name/brand\_level/wyc\_pricing\_enabled 为 compute，其它 result）。

**下一步的具体动作（不写业务逻辑，只做跑批与 QA 骨架）**：

* 在 `data/raw/sample/` 放 10–50 条**最小样例**（含至少两种 `source`、含 3–5 个冲突样例）。
* 运行两条命令：

  1. `python scripts/validate_configs.py --root . --manifest conf/manifest.yaml --strict`（先过配置）
  2. `python scripts/qa_check.py`（你已有；用于三表与 P0 命中率）
* 产出三份文件（空跑骨架也行，先看结构）：

  * `output/tall/tall_{YYYYMMDD}_{HHMM}.csv`（含三槽+证据侧写位列头）
  * `output/hot/hot_{YYYYMMDD}_{HHMM}.csv`（13 列横表）
  * `output/qa/qa_{YYYYMMDD}_{HHMM}.json`（覆盖率/域外值率/兜底率/新鲜度/变更率+反向校验）
* 将本批次策略与三表快照落在：`logs/snapshots/snap_{YYYYMMDD}_{HHMM}/`（为第 4 步回放做准备）。

你可以先把我给的 **`validate_configs.py`** 落地运行一遍，把输出 JSON 贴过来；如果 `ok=true`，我们就直接进入“最小样例跑批 + QA 骨架”的产出，主线就从第 3 步跨进第 4 步了。
