# 商户画像｜配置清单（TTL/合并策略/QA 阈值）与参考加载代码｜v1.0

> 说明：本页专门沉淀**可配置项**与**参考加载代码**。落地后将纳入快照与回放范围。

## 1) 目录与 manifest

```
conf/
├─ policies/
│  ├─ ttl.yaml              # TTL 策略（按 tag/source 配置）
│  └─ merge_policy.yaml     # 多源算法策略（预置权重 + 覆盖）
└─ qa/
   └─ metrics.yaml          # QA 阈值与等级
```

示例 manifest 片段：

```yaml
version: 1.0
policies:
  ttl: conf/policies/ttl.yaml
  merge: conf/policies/merge_policy.yaml
qa:
  metrics: conf/qa/metrics.yaml
snapshots:
  include_patterns:
    - conf/policies/*.yaml
    - conf/qa/*.yaml
```

## 2) TTL 策略（`conf/policies/ttl.yaml`）

```yaml
version: 1.0
updated_at: 2025-09-19

ttl:
  default_days: 30
  by_tag:
    brand_name: 90
    open_24h: 7
  by_tag_source:
    brand_name:
      s1: 60
      s2: 30
```

**优先级**：by\_tag\_source ＞ by\_tag ＞ default\_days；缺失则置 `evidence_state=TTL_NOT_SET`。

## 3) 多源合并策略（`conf/policies/merge_policy.yaml`）

```yaml
version: 1.0
updated_at: 2025-09-19

strategy: balanced   # conservative / balanced / aggressive / custom

presets:
  conservative: { weights: { C_source: 0.60, C_fresh: 0.25, C_rule: 0.05, C_match: 0.10 } }
  balanced:     { weights: { C_source: 0.40, C_fresh: 0.30, C_rule: 0.10, C_match: 0.20 } }
  aggressive:   { weights: { C_source: 0.25, C_fresh: 0.50, C_rule: 0.05, C_match: 0.20 } }

functions:
  conf_formula: geo
  freshness: { type: exp, params: { tau_days: 14 } }
  rule_completeness: { regex_pass: 1.0, fallback: 0.5, invalid: 0.0 }
  tie_break_order: [ conf_desc, observed_at_desc, C_source_desc, source_whitelist, source_lexi_asc ]

sources:
  weights:   { s1: 0.9, s2: 0.7, s3: 0.5 }
  whitelist: [ s1 ]
  blacklist: [ ]

overrides:
  by_tag:
    brand_name:
      weights: { C_source: 0.50, C_fresh: 0.30, C_rule: 0.10, C_match: 0.10 }
      freshness: { type: exp, params: { tau_days: 7 } }
  by_tag_source:
    brand_name:
      s2:
        weights: { C_source: 0.30, C_fresh: 0.50, C_rule: 0.10, C_match: 0.10 }
```

**规则**：

* 黑名单命中 ⇒ `evidence_state=SOURCE_BLACKLISTED`，退出评分；
* by\_tag\_source / by\_tag 对 presets 的覆盖优先级：by\_tag\_source ＞ by\_tag；
* `conf = C_source^w1 × C_fresh^w2 × C_rule^w3 × C_match^w4`；
* `C_rule`：regex=1.0，fallback=0.5（采用口径 A），invalid=0.0。

## 4) QA 阈值（`conf/qa/metrics.yaml`）

```yaml
version: 1.0
updated_at: 2025-09-19

thresholds:
  out_of_enum_rate: { warn: 0.01, error: 0.05 }
  fallback_rate:    { warn: 0.05, error: 0.10 }
  changed_rate:     { warn: 0.05, error: 0.10 }
  freshness_lag_h:  { warn: 24,   error: 72   }

reverse_checks:
  open_24h:
    hours_cover_full_day: true
```

## 5) 参考加载代码（Python）

```python
from dataclasses import dataclass
from typing import Dict, Any
import yaml, math, datetime as dt

def load_yaml(path: str) -> Dict[str, Any]:
    with open(path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f) or {}

@dataclass
class TTLPolicy:
    default_days: int
    by_tag: Dict[str, int]
    by_tag_source: Dict[str, Dict[str, int]]
    @classmethod
    def from_yaml(cls, y: Dict[str, Any]):
        t = y.get('ttl', {})
        return cls(
            default_days=int(t.get('default_days', 0) or 0),
            by_tag={k:int(v) for k,v in (t.get('by_tag') or {}).items()},
            by_tag_source={k:{ks:int(vs) for ks,vs in vv.items()} for k,vv in (t.get('by_tag_source') or {}).items()}
        )
    def ttl_days(self, tag_code: str, source: str) -> int:
        if tag_code in self.by_tag_source and source in self.by_tag_source[tag_code]:
            return self.by_tag_source[tag_code][source]
        if tag_code in self.by_tag:
            return self.by_tag[tag_code]
        return self.default_days

@dataclass
class MergePolicy:
    weights: Dict[str, float]
    freshness: Dict[str, Any]
    rule: Dict[str, float]
    tie_break: list
    src_weights: Dict[str, float]
    src_whitelist: set
    src_blacklist: set
    @classmethod
    def from_yaml(cls, y: Dict[str, Any]):
        strat = (y.get('strategy') or 'balanced').lower()
        presets = y.get('presets') or {}
        base_w = (presets.get(strat) or presets.get('balanced'))['weights']
        weights = dict(base_w)
        freshness = y.get('functions', {}).get('freshness', {"type":"exp","params":{"tau_days":14}})
        rule = y.get('functions', {}).get('rule_completeness', {"regex_pass":1.0, "fallback":0.5, "invalid":0.0})
        tie_break = y.get('functions', {}).get('tie_break_order', [])
        src = y.get('sources', {})
        return cls(
            weights=weights,
            freshness=freshness,
            rule=rule,
            tie_break=tie_break,
            src_weights=src.get('weights', {}),
            src_whitelist=set(src.get('whitelist', []) or []),
            src_blacklist=set(src.get('blacklist', []) or [])
        )
    def freshness_score(self, observed_at: dt.datetime, as_of_date: dt.date) -> float:
        typ = (self.freshness.get('type') or 'exp').lower()
        if typ == 'exp':
            tau = float(self.freshness.get('params', {}).get('tau_days', 14))
            delta = (as_of_date - observed_at.date()).days
            return math.exp(-max(delta,0)/max(tau,1e-6))
        return 1.0
    def source_weight(self, source: str) -> float:
        return float(self.src_weights.get(source, 0.5))

def compute_conf(policy: MergePolicy, *, source: str, observed_at: dt.datetime,
                 as_of_date: dt.date, match_score: float, regex_pass: bool,
                 used_fallback: bool, invalid: bool) -> float:
    if source in policy.src_blacklist:
        return 0.0
    C_source = policy.source_weight(source)
    C_fresh  = policy.freshness_score(observed_at, as_of_date)
    C_rule   = 0.0 if invalid else (policy.rule['fallback'] if used_fallback else policy.rule['regex_pass'])
    C_match  = float(match_score)
    w = policy.weights
    conf = (C_source**w['C_source']) * (C_fresh**w['C_fresh']) * (C_rule**w['C_rule']) * (C_match**w['C_match'])
    return max(0.0, min(1.0, conf))
```

> 以上三份配置 + 加载代码，满足你提的“凡可能配置的，都应有**配置文档**与**对应配置代码**”。落地后可直接纳入快照与回放。
