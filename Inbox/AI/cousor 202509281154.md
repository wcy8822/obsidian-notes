太对了：**逻辑要实、路径要抽象**。下面我把“哪些需要配置、怎么配置到你现有几张表里，以及推荐的定义句式/建议值”一次梳理清楚。末尾附一份统一**字段解释字典**，避免跑偏。

---

ln -s /Users/didi/Downloads/panth/tag_ct_clean/docs /Users/didi/Downloads/panth/sync/obsidian/Projects/_Active/商户画像/标签清洗系统

```

ln -s /Users/didi/Downloads/panth/tag_ct_clean/docs /Users/didi/Downloads/panth/sync/obsidian/Projects/_Active/商户画像/标签清洗系统
```

# 一、最小可运行的“必配项”（只要这些在，AI就能跑）

> 这些是**必须**能从你现有字典里读到的键值；放哪张表我给两种落位方式（结构化/内嵌），你选其一。

1. **源权重（w\_source_s*）**：每个 `tag_code` 的 S1–S4 权重
	1. 例如,|   |   |   |   |
|---|---|---|---|
|w_source_s1|w_source_s2|w_source_s3|w_source_s4|
2. **新鲜度规则**：`ttl_days`、`decay_mode ∈ {linear, exp}`
3. **分差阈值（delta_min）**：判定 SELECTED vs CONFLICT
4. **是否参与决胜（is\_decidable）**：有些标签仅存证，不决胜
5. **枚举域（可选）**：`enum_values / 匹配规则`（若为 enum/bool）
6. **逆向检查规则**（二选一）：

   * 时间窗法：`expected_window_days = N`
   * 对比法：`expected_from_diff = true`
7. **QA 阈值**（前置阻断）：`enum_invalid_rate_max / store_map_fail_rate_max / ts_missing_rate_max`
8. **HOT 展开口径**：`hot_fill_policy ∈ {blank, UNKNOWN, last_value}`

---

# 二、配置“落位方式”（不改路径，只说放哪里）

> 你已有 **tag\_spec.csv / tag\_catalog.csv / tag\_enum.csv / sources.yaml**。下面给两种写法：**A 结构化列（推荐）** 或 **B definition JSON 内嵌（不加列）**。二选一即可。

## A. 结构化列（推荐，查询直观）

* **tag\_spec.csv（按标签×源覆写）**

  * 新增/确认列：`tag_code, source_id, source_weight, ttl_days_override, decay_mode_override, delta_min_override, effective_from, effective_to, approved_by, approved_at`
  * 用途：有覆写就用，没覆写回退到 catalog 的默认
* **tag\_catalog.csv（按标签默认）**

  * 新增/确认列：`tag_code, is_decidable, ttl_days_default, decay_mode_default, delta_min_default, hot_fill_policy`
* **tag\_enum.csv**

  * 你已有：`enum_code/label/aliases/match_method/match_score_threshold/alias_norm_rule...`，保持即可
* **sources.yaml**

  * 新增块（示意）：

    ```yaml
    quality_thresholds:
      enum_invalid_rate_max: 0.01
      store_map_fail_rate_max: 0.01
      ts_missing_rate_max: 0.02
    reverse_check:
      expected_window_days: 7      # 或 expected_from_diff: true
    ```

## B. 不增列（definition 内嵌 JSON）

* **tag\_spec.csv**

  * 用 `definition` 列写 JSON 文本，例如：

    ```json
    {
      "W_source": {"S1":1.0,"S2":0.85,"S3":0.7,"S4":0.6},
      "ttl_days": 14,
      "decay_mode": "exp",
      "delta_min": 0.10
    }
    ```
* **tag\_catalog.csv**

  * 用 `fallback` 或 `calc_type`/`definition` 承载：

    ```json
    {"is_decidable": true, "ttl_days_default": 30, "decay_mode_default": "linear", "delta_min_default": 0.10, "hot_fill_policy": "UNKNOWN"}
    ```
* **sources.yaml** 同上（推荐把全局阈值放这里）

> 结论：**能结构化就结构化；不方便加列时，就把内容 JSON 化写进现有文本列**。

---

# 三、给 AI 的“可读句式模板”（粘贴即可用）

## 1) 取值与打分（两维收敛）

```
对同一 (store_id, tag_code) 的候选集合：
score = W_source(tag_code, source_id) × F_fresh(observed_at, ttl_days, decay_mode)
F_fresh:
  linear: max(0, 1 - age_days/ttl_days)
  exp:    exp(-ln2 × age_days / (ttl_days/2))
选择：
  若 max(score) - second_max(score) ≥ Δ_min(tag_code) → SELECTED
  若 < Δ_min → CONFLICT
  若所有 score=0 → UNKNOWN
```

**需要 AI 能读到**：`W_source, ttl_days, decay_mode, Δ_min`（按“tag\_spec 覆写 > tag\_catalog 默认”的优先级）。

## 2) 逆向检查（预期变更→是否生效）

```
预期变更定义（择一）：
  A 时间窗法：observed_at ≥ now - expected_window_days
  B 对比法：与上期候选对比，出现新 (store_id, tag_code, source_id, value)
判定：
  若本期 SELECTED 值 == 预期值 → APPLIED
  否则 → NOT_APPLIED，原因枚举：
    WEIGHT_LOWER / STALE / SMALL_DELTA / ENUM_INVALID / MERGE_CONFLICT / OTHER
```

**需要 AI 能读到**：`expected_window_days` 或 `expected_from_diff`。

## 3) HOT 只做展开（不再决策）

```
仅将 <TALL> 中 is_selected=1 的行按列展开；
CONFLICT/UNKNOWN 的位置按 hot_fill_policy 输出：blank / UNKNOWN / last_value。
```

---

# 四、标签“建议值”与口径（拍板就能跑）

> 你要“逻辑具体，路径抽象”，我只给**建议区间/默认**，不写死。

| 标签范式                       | W\_source（示意）                 | TTL & 衰减      | Δ\_min（建议） | 备注          |
| -------------------------- | ----------------------------- | ------------- | ---------- | ----------- |
| 品牌归属（brand\_name/level）    | S1≥0.95，S2≤0.6，S3≤0.6，S4≤0.5  | TTL=90，linear | 0.20       | 稳定类，权威优先    |
| 重叠站（competitive\_overlap）  | S4≈0.9，S2≈0.8，S1≈0.75，S3≈0.6  | TTL=14，exp    | 0.10       | 时效敏感，线上证据优先 |
| 站内服务（wash/cstore/parking）  | S2≈0.95，S3≈0.85，S1≈0.8，S4≈0.7 | TTL=30，exp    | 0.10       | 现场优先        |
| 营业时段（open\_24h/biz\_hours） | S3≈0.9，S2≈0.85，S1≈0.7，S4≈0.7  | TTL=7，exp     | 0.10       | 高频变动        |

> 这些写入 **tag\_catalog 默认**；需要更细就用 **tag\_spec 按源覆写**。

---

# 五、前置校验（可配置项与建议阈值）

> 写在 `sources.yaml.quality_thresholds` 或 `tag_catalog` 的“全局行”里。

* `enum_invalid_rate_max`: 0.01（1%）
* `store_map_fail_rate_max`: 0.01
* `ts_missing_rate_max`: 0.02
* `mandatory_sources`: 例如 `{"brand_name": ["S1"]}`
* `meta_required`: 需要写入 `run_id, algo_version, source_snapshot_ids`

AI 的处理语义：**超过阈值→阻断；未达阈值→记录并继续**。

---

# 六、常见“定义句”示例（直接抄用到 definition 文本里）

* 取值原则：
  “本标签采用**两维打分**：score = W\_source × F\_fresh。`Δ_min=0.10`；TTL=14 天；decay='exp'；优先级倾向 S4>S2>S1>S3。”
* 决胜口径：
  “同一站同一标签仅产一条 SELECTED；分差不足产 CONFLICT；全 0 产 UNKNOWN。”
* HOT 展开口径：
  “HOT 仅采用 SELECTED；CONFLICT/UNKNOWN 用 `UNKNOWN` 填充，不回填上期值。”
* 逆向检查口径：
  “预期变更以 `expected_window_days=7` 判定；结果一致记 APPLIED，反之 NOT\_APPLIED 并标注原因。”

---

# 七、行动清单（3 步收口）

1. **决定落位方式**：A 结构化列或 B definition JSON（只选一种，全局一致）。
2. **补齐最小键值**：为 P0 标签填上 `W_source/ttl/decay/Δ_min/is_decidable/hot_fill_policy`；sources.yaml 写上 `quality_thresholds` 与 `reverse_check`。
3. **写进 definition 的标准句式**：把上面的“定义句”贴到对应标签的 definition 字段（或转成结构化列）。

---

## 字段解释字典（统一放在最后）

* `W_source(tag_code, source_id)`：源权重，0–1 浮点；按标签可覆写
* `ttl_days`：有效期（天）；超期后新鲜度逼近 0
* `decay_mode`：新鲜度衰减方式，`linear` 或 `exp`
* `Δ_min`：Top1 与 Top2 的最小分差阈值
* `is_decidable`：bool，是否纳入决胜
* `enum_values / match_method / match_score_threshold / alias_norm_rule`：枚举匹配规则集合
* `expected_window_days / expected_from_diff`：逆向检查“预期变更”的判定方式
* `quality_thresholds`：前置阻断阈值集合
* `hot_fill_policy`：HOT 对 CONFLICT/UNKNOWN 的填充策略（`blank/UNKNOWN/last_value`）
* `run_id / algo_version / source_snapshot_ids`：版本追溯元数据（全表常量）

---

如果你要，我可以把“结构化列方案”和“definition JSON 方案”各自再产出**一份最小示例（3 行样例）**，你直接拷进现有字典验证读写是否顺滑。下一步也可以一起挑 2–3 个 P0 标签，现场把权重/TTL/阈值拍出来，参数就定版了。
