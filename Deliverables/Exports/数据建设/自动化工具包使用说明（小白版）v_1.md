# 自动化工具包使用说明（小白版）v1.0

> 这份说明配套你拿到的 `auto_raw_pack_templates.zip`。定位：**业务侧只写 CSV & Excel**，**不用 JSON/YAML**；脚本负责把 Excel → 四源 RAW CSV，并生成 `manifest.csv`。DE 侧会把这些 CSV 承接为分区 RAW，再进 STD/INPUT/OUTPUT。

---

## 0. 最重要的共识：业务只用 `tag_code`，不需要 `tag_id`

- **你填表时，一律使用 **``**（英文码）**：`tag_catalog.csv / tag_spec.csv / tag_enum.csv` 都是以 `` 为主键视角。
- ``** 是 DE 的“内部主键”（可用 UUID/哈希）**：DE 会在入库时生成 `tag_id` 并维护 `tag_id_map(tag_code↔tag_id)`，随后把治理/事实表联动起来，供执行与查询层使用。
- **你不需要、也不应该在业务 CSV 里填写 **``，避免二次维护带来的不一致。

**DE 侧映射（示意）**

```sql
-- 1) 生成或更新 tag_id_map（一次性 + 增量）
MERGE INTO tag_id_map t
USING (SELECT DISTINCT tag_code FROM tag_catalog_src) s
ON (t.tag_code = s.tag_code)
WHEN NOT MATCHED THEN INSERT (tag_code, tag_id) VALUES (s.tag_code, uuid());

-- 2) 写入治理层（内部表用 tag_id 存储）
INSERT OVERWRITE TABLE tag_catalog
SELECT m.tag_id, c.tag_code, c.tier1, c.tier2, c.tier3, c.tag_class, c.owner_biz, c.owner_data, c.status
FROM tag_catalog_src c JOIN tag_id_map m ON c.tag_code = m.tag_code;

INSERT OVERWRITE TABLE tag_spec
SELECT m.tag_id, s.spec_version, s.definition, s.value_type, s.fallback,
       s.effective_from, s.effective_to, s.approved_by, s.approved_at
FROM tag_spec_src s JOIN tag_id_map m ON s.tag_code = m.tag_code;

INSERT OVERWRITE TABLE tag_enum
SELECT m.tag_id, e.spec_version, e.enum_code, e.enum_label, e.sort_order, e.is_default
FROM tag_enum_src e JOIN tag_id_map m ON e.tag_code = m.tag_code;

-- 3) “当前生效视图”按 tag_id 统一对外
CREATE OR REPLACE VIEW vw_tag_spec_current AS
SELECT * FROM tag_spec WHERE effective_to IS NULL;
```

> 注：`*_src` 指业务 CSV 的落库中间表；是否 `OVERWRITE`/`MERGE` 由 DE 决定。

---

## 1. 目录结构长什么样？（开包即可用）

```
/auto_raw_pack/
  ├─ GOVERNANCE_TEMPLATES/
  │    ├─ tag_catalog.csv
  │    ├─ tag_spec.csv
  │    ├─ tag_enum.csv
  │    ├─ tag_quality_policy.csv
  │    ├─ tag_source_registry.csv
  │    └─ tag_testset.csv
  ├─ RAW_DELIVERY_TEMPLATE/
  │    └─ BATCH_YYYYMMDD_A/
  │         ├─ raw_s1_official_tag_staging.csv
  │         ├─ raw_s2_ops_tag_staging.csv
  │         ├─ raw_s3_correction_tag_staging.csv
  │         ├─ raw_s4_intel_tag_staging.csv
  │         ├─ manifest.csv
  │         ├─ brand_alias_delta.csv
  │         ├─ trace_lines.csv
  │         └─ mapping_rules.csv
  └─ SCRIPTS/
       └─ auto_pipeline.py
```

---

## 2. 我到底先填哪些？按这个顺序走就对了

**步骤 1｜填治理三件套（只用 tag\_code）**

1. `GOVERNANCE_TEMPLATES/tag_catalog.csv`：先把 **P0=13** 的 `tag_code` 与层级、Owner 录进去。
2. `GOVERNANCE_TEMPLATES/tag_spec.csv`：为每个 `tag_code` 写 `spec_version / value_type / fallback / 生效期`。
3. `GOVERNANCE_TEMPLATES/tag_enum.csv`（若 `value_type=enum`）：为每个 `tag_code@spec_version` 列出全部合法取值：

```
tag_code,spec_version,enum_code,enum_label,sort_order,is_default
brand_level,1.0.0,KA,KA,10,false
brand_level,1.0.0,CKA,CKA,20,false
brand_level,1.0.0,SMALL,小散,30,true
brand_display,1.0.0,BRAND_0001,中国石化,10,false
brand_display,1.0.0,BRAND_0002,壳牌,20,false
brand_display,1.0.0,other,其他,999,true
```

> 你只负责 `tag_code/enum_code/enum_label` 等业务可读内容；`tag_id` 全部由 DE 入库时生成。

**步骤 2｜（可选）字典增量**\
若某些标签需要“别名→标准ID”的清洗（如品牌），在 `brand_alias_delta.csv` 填：

```
dict_id,brand_id,brand_name_std,alias,match_type,priority,valid_from,valid_to,status,spec_version,rule_version
BRAND_ALIAS_V1,BRAND_0001,中国石化,中石化|中石化集团,regex,1,2024-01-01,2099-12-31,enabled,1.0.0,1.0.0
```

**步骤 3｜写映射规则（mapping\_rules.csv）**\
告诉脚本：从 **Excel 哪一列** 取值，变换成**哪个标签**的**哪个槽位**：

```
source,sheet,tag_code,value_type,store_id_col,as_of_date_col,source_column,transform,const_value,target_slot,evidence_state_default,ttl_days_default,reason_default,conf_default
S2,Sheet1,brand_display,string,store_id,as_of_date,brand_text,brand_alias_lookup:file=brand_alias_delta.csv,,target_value_string,Normal,,,85
S3,Sheet1,overlap,bool,store_id,as_of_date,overlap_flag,bool_map:1|0|99,,target_value_bool,Locked,180,竞对强匹配+价露出,100
```

- `transform` 可选：`brand_alias_lookup:file=...` / `bool_map:1|0|99` / `enum_passthrough` / `number_passthrough` / `id_passthrough`。
- `target_slot` 只允许 `target_value_string/number/bool` 三选一（**三槽位互斥**）。

**步骤 4｜准备 Excel 源数据**\
至少包含 `store_id`、`as_of_date`、以及 `mapping_rules.csv` 所指明的源列（如 `brand_text` / `overlap_flag`）。

**步骤 5｜运行脚本（生成四源 CSV + manifest）**

```bash
python SCRIPTS/auto_pipeline.py build \
  --excel /路径/source.xlsx \
  --mapping /路径/RAW_DELIVERY_TEMPLATE/BATCH_YYYYMMDD_A/mapping_rules.csv \
  --gov /路径/GOVERNANCE_TEMPLATES \
  --out /路径/RAW_DELIVERY_TEMPLATE/BATCH_YYYYMMDD_A \
  --batch-id BATCH_YYYYMMDD_A \
  --producer 业务-姓名
```

运行后会生成/覆盖：

- `raw_s1_official_tag_staging.csv` … `raw_s4_intel_tag_staging.csv`
- `manifest.csv`（含各源行数/站点数摘要）

**步骤 6｜交付“四件套”给 DE**\
四源 CSV + `manifest.csv` + （如有）`brand_alias_delta.csv` + `trace_lines.csv`。

---

## 3. 小白能懂的一些“为什么”

- **为什么我只见到 **``** 没有 **``**？**\
  因为 `tag_id` 是系统内部的技术主键，便于稳定关联和变更历史；业务维护 `tag_code` 更直观、可读。DE 在入库时自动生成 `tag_id` 并完成映射。
- ``** 写中文可以吗？**\
  不建议。`enum_code` 是**存储值**（例如 `BRAND_0001`/`KA`），展示层再用 `tag_enum` 的 `enum_label` 映射到中文。
- ``** 有什么用？**\
  纯展示序（10、20、30… 方便中间插入）；`other/未知` 建议给 999。
- ``** 怎么用？**\
  对齐 `tag_spec.fallback`。例如 `brand_display` 回退 `other`，则把 `other` 这一行 `is_default=true`。
- **S3 订正为什么要 **``**？**\
  订正是最高优先级，但不能永久压制自动规则，所以要有 TTL，过期自动降级为 `Normal` 再回到算法/规则接管。

---

## 4. 常见错误与排查（你能自己搞定的）

- CSV 不是 UTF-8 无 BOM / 逗号分隔 / `\n` 换行 → 用文本编辑器另存为 UTF-8。
- 三槽位（`*_bool/number/string`）填了两列以上 → 只保留一个，其他置空。
- `as_of_date` 写成了上传日 → 以“观察日”为准；DE 承接按 ``** 分区**。
- 布尔写了 `true/false/是/否` → 用 `1/0/99`。
- `enum_code` 写中文 → 改为 code；中文放 `enum_label`。
- 品牌别名命中多个品牌 → 用 `priority` 决定；无法判定的行写入 `trace` 并人工复核。

---

## 5. 我还需要告诉 DE 什么？（交接清单）

- 这批次的目录路径与 `batch_id`；
- 你更新的 `tag_catalog/spec/enum` 三件套；
- 若使用了别名映射：随包提供 `brand_alias_delta.csv`；
- 期望承接的日期范围（通常即 `manifest.csv` 的 `as_of_date_start/end`）。

---

## 6. FAQ（再强调一遍）

**Q1：我需要在 CSV 里填写 **``** 吗？**\
A：不需要。只填 `tag_code`，DE 生成 `tag_id` 并维护映射。

**Q2：我想先试 2–3 个标签可以吗？**\
A：可以。`tag_catalog/spec/enum` 里先放 P0 中的 2–3 个，`mapping_rules.csv` 也先写 2 行即可。

**Q3：能不能把 Excel 的中文列名直接用？**\
A：可以，脚本会按 `mapping_rules.csv` 里指定的列名抓数据（大小写要一致）。

**Q4：脚本会拒收不合规行吗？**\
A：当前版本会**丢弃**多槽位非空的行并打印警告；下一版可输出 `rejects.csv` 明细（如需请你说“开 rejects”）。

---

> 以上是“人类可读、上手即用”的工具说明。若你拍板，我把这份说明也嵌到《RAW 业务可投喂包 · 模板》文末，作为**工具附录**。

