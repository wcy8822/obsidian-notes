# 架构调整补丁 v1（Tall 真相层 + Hot 宽层）
> 目的：解决“标签列爆炸”（200 标签×7件套=1400 列）的问题；在不破坏已交付 P0 的前提下，升级为**Tall 真相层 + Hot 宽层**的混合架构。确保可回放、可回滚、可扩展，并向下兼容。

---

## 0. TL;DR（改了什么、不变什么）
**不变**：
- A/B 方法论（A=线下上翻+证据阶梯；B=纯线上+契约）不变。
- 治理10表（批次1）、标签规格卡（批次3）、规则DSL与SQL（批次4）、情报源（批次5）不变。
- 质量闸门 Acc≥90 / Cov≥90 / Fresh=T+1 / Stable≤5% 不变。

**变化**：
- **新增** 真相层表：`tag_value_fact`（Tall，一行=站点×日期×三级标签）。
- **新增** 证据表：`tag_trace`（trace 外置，减小扫描开销）。
- **新增** 热点白名单：`tag_wide_hot_list`。
- **调整** 原“全量宽表”语义：将 `tag_wide_daily` 定位为 **Hot 宽层**（仅物化前 N 个常用标签；默认 N=50，可按需增减）。
- **兼容**：提供 `tag_wide_daily_compat` 视图给已有消费者（仅映射 P0；后续按白名单扩展）。

---

## 1. 数据模型（新）
### 1.1 维度与治理（沿用批次1）
- `tag_catalog / tag_spec / tag_enum / tag_quality_policy / tag_rule_config / tag_detector_config / tag_release / tag_change_log / tag_testset`。

### 1.2 真相层（Tall）：`tag_value_fact`（**新建**）
> 一行 = `station_gid × as_of_date × tag_id`。
```sql
CREATE TABLE IF NOT EXISTS tag_value_fact (
  as_of_date DATE NOT NULL,
  station_gid STRING NOT NULL,
  tag_id STRING NOT NULL,             -- 三级标签ID（对应 tag_catalog.tag_id）

  -- 值槽位（按 value_type 仅用其中一个；其余为空）
  value_string STRING,                -- 枚举/ID/文本（存 enum_code 或 ID）
  value_number DECIMAL(18,6),         -- 数值类
  value_bool SMALLINT,                -- 1/0/99（布尔/有无）

  -- 七件套（公共部分）
  source STRING,                      -- official/region/ops/external/intel/fusion
  conf INT,                           -- 0~100
  ver STRING,                         -- 规则/口径版本
  class STRING,                       -- 'A'/'B'
  evidence_state STRING,              -- Unknown/Candidate/Inferred/Verified/Locked
  trace_id STRING,                    -- 指向 tag_trace.trace_id

  -- SCD2 控制
  effective_from TIMESTAMP,
  effective_to   TIMESTAMP,
  is_current     BOOLEAN,
  updated_at     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  PRIMARY KEY (station_gid, as_of_date, tag_id)
);
-- 分区建议：按 as_of_date 分区；大表引擎可对 station_gid 做二级索引/分桶
```

**值使用规则**：
- `tag_dim.value_type = 'bool'` → 写 `value_bool`（1/0/99）。
- `= 'enum'/'id'/'text'` → 写 `value_string`（枚举写 enum_code，展示层 join `tag_enum` 显示中文）。
- `= 'number'` → 写 `value_number`。
- **检查**：ETL 端保证“**仅一个槽位非空**”，否则视为违规并告警。

### 1.3 证据表：`tag_trace`（**新建**）
```sql
CREATE TABLE IF NOT EXISTS tag_trace (
  trace_id STRING PRIMARY KEY,        -- UUID
  station_gid STRING,
  tag_id STRING,
  as_of_date DATE,
  trace_json STRING,                  -- 证据/ER匹配/探测器命中等完整 JSON
  size_bytes INT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 1.4 热点白名单：`tag_wide_hot_list`（**新建**）
```sql
CREATE TABLE IF NOT EXISTS tag_wide_hot_list (
  tag_id STRING PRIMARY KEY,
  comment STRING,
  added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 1.5 Hot 宽层：`tag_wide_daily`（**语义调整**）
> 不再试图“容纳所有标签列”，仅对 `tag_wide_hot_list` 白名单内的标签做列展开（七件套）。
- **P0 方案**：白名单先放 13 个 P0 标签，与你原来的 `tag_wide_daily` 字段保持一致（完全兼容）。
- **扩展**：新增标签 → 只改白名单与生成脚本，无需改事实表结构。

### 1.6 兼容视图：`tag_wide_daily_compat`（**新增**）
> 映射至当前 `tag_wide_daily` 字段，给已有报表/策略使用，逐步引导迁移到 Tall 查询或 Hot 宽层。

---

## 2. 写入与调度（流程不变，落点改变）
**RAW → STD → ER → A/B 规则 → QA → 发布**：
- A 类：融合后 **写入 `tag_value_fact`**（选择正确的值槽位），生成 `trace_id` 并写 `tag_trace`。
- B 类：契约校验通过，**写入 `tag_value_fact`**（`evidence_state='Verified'`）。
- **物化 Hot 宽层**：每日 04:00 根据 `tag_wide_hot_list` 做 PIVOT，生成/刷新 `tag_wide_daily`。

---

## 3. 生成 Hot 宽层的实现（示例）
> 不同引擎有不同方式；下面给出通用思路与 Hive/StarRocks 伪代码。

### 3.1 准备：白名单装载
```sql
-- P0 先装 13 个三级标签
INSERT INTO tag_wide_hot_list(tag_id,comment) VALUES
('brand_level','P0'),('brand_display','P0'),('overlap','P0'),
('mid_vendor_exists','P0'),('mid_vendor_name','P0'),
('ns_unique_pricing','P0'),
('service_carwash_exists','P0'),('service_carwash_type','P0'),
('service_store_exists','P0'),('service_restroom_exists','P0'),
('service_parking_exists','P0'),('open_24h','P0'),('open_hours','P0');
```

### 3.2 动态 PIVOT 的思路
1) 从 `tag_value_fact` 取当日 `as_of_date=D-1 AND is_current` 且 `tag_id ∈ 白名单` 的记录。
2) 按 `tag_id` 生成列名：`tag_{code}_{suffix}`（七件套），`code` 来自 `tag_catalog.tag_code`。
3) 以 `station_gid` 为行键展开；公共主体列通过 `dim_store/dim_station_master` 关联填充。

### 3.3 伪代码（Hive/StarRocks）：
```sql
-- Step 0: 拉取白名单 + 生成列清单（在调度侧模板化生成SQL）
-- 假设拿到清单：['brand_level','brand_display', ...]

-- Step 1: 取 Tall 数据
WITH fact AS (
  SELECT f.as_of_date, f.station_gid, f.tag_id,
         COALESCE(f.value_string, CAST(f.value_number AS STRING), CAST(f.value_bool AS STRING)) AS v,
         f.source, f.conf, f.ver, f.class, f.evidence_state, f.trace_id
  FROM tag_value_fact f
  WHERE f.as_of_date = ${biz_date} AND f.is_current = TRUE
    AND f.tag_id IN (SELECT tag_id FROM tag_wide_hot_list)
),
meta AS (
  SELECT c.tag_id, c.tag_code FROM tag_catalog c
  WHERE c.tag_id IN (SELECT tag_id FROM tag_wide_hot_list)
)
-- Step 2: 透视（调度侧拼接生成多列 MAX(CASE WHEN)）
SELECT s.as_of_date, s.station_gid,
       d.store_id, d.store_name, d.pop_id, d.pop_name,
       d.contract_party_name, d.business_registration_no,
       d.province, d.city, d.lng, d.lat,
       -- 以 brand_level 为例：
       MAX(CASE WHEN f.tag_id='brand_level' THEN f.v END) AS tag_brand_level_value,
       MAX(CASE WHEN f.tag_id='brand_level' THEN f.source END) AS tag_brand_level_source,
       MAX(CASE WHEN f.tag_id='brand_level' THEN f.conf END)   AS tag_brand_level_conf,
       MAX(CASE WHEN f.tag_id='brand_level' THEN f.ver END)    AS tag_brand_level_ver,
       MAX(CASE WHEN f.tag_id='brand_level' THEN f.class END)  AS tag_brand_level_class,
       MAX(CASE WHEN f.tag_id='brand_level' THEN f.evidence_state END) AS tag_brand_level_evidence_state,
       MAX(CASE WHEN f.tag_id='brand_level' THEN f.trace_id END)       AS tag_brand_level_trace,
       -- 其余白名单标签按模板展开 ...
FROM (SELECT DISTINCT as_of_date, station_gid FROM fact) s
LEFT JOIN dim_station_master d USING(station_gid)
LEFT JOIN fact f USING(as_of_date, station_gid)
GROUP BY s.as_of_date, s.station_gid, d.store_id, d.store_name, d.pop_id, d.pop_name,
         d.contract_party_name, d.business_registration_no, d.province, d.city, d.lng, d.lat;
```

> 调度器通过标签清单自动生成上面那段 `MAX(CASE WHEN tag_id=... THEN ... END)` 列段，避免手写 7×N 列。

---

## 4. 向下兼容与迁移
- **阶段1（并行期）**：
  - 新建 `tag_value_fact/tag_trace/tag_wide_hot_list`；
  - 继续产出原 `tag_wide_daily`（仅 P0）并同步生成 `tag_wide_daily_compat` 视图；
  - 新消费者一律走 `tag_value_fact` 或 Hot 宽层。
- **阶段2（切换期）**：
  - 报表/策略逐步迁到 `tag_wide_daily`（Hot 宽层）或直接 Tall 查询；
  - 审核稳定后，停止“全量宽表”的构建（若仍存在旧产线）。
- **阶段3（收尾）**：
  - `tag_wide_daily` 仅由白名单驱动；`tag_wide_daily_compat` 保留 1~2 个发布周期后下线。

---

## 5. 风险点与防护
- **风险1：取值槽位误用** → 在 ETL 增加 **互斥校验**（仅一个槽位非空），不合规阻断并告警。
- **风险2：trace 过大** → 限制 `size_bytes`，超过阈值仅保留关键字段；原文外链存对象存储。
- **风险3：动态 PIVOT 复杂** → 由调度器/脚本根据白名单生成 SQL；发版需附带白名单变更审计。
- **风险4：旧消费者读取路径** → 提供 `tag_wide_daily_compat` 视图；保留两个发布周期的灰度。

---

## 6. 验收清单（上线必过）
1. 三张新表建表成功（含注释/权限/血缘登记）。
2. A/B 产线均写入 `tag_value_fact`；trace 可追；抽样 ≥50 样本准确。
3. `tag_wide_hot_list` 装载 P0=13；`tag_wide_daily` 产出字段与旧版一致。
4. 质检牌照：Acc/Cov ≥90%，Stable ≤5%，Fresh=T+1。
5. 回放/回滚演练：指定 as_of_date & rule_version 能成功覆盖重算与回滚。

---

## 7. 示例查询（给 DE/BI）
- **Tall：拉某站当日所有标签**
```sql
SELECT f.tag_id, c.tier1, c.tier2, c.tier3, s.value_type,
       COALESCE(f.value_string, CAST(f.value_number AS STRING), CAST(f.value_bool AS STRING)) AS value,
       f.source, f.conf, f.ver, f.class, f.evidence_state, f.trace_id
FROM tag_value_fact f
JOIN tag_catalog c USING(tag_id)
JOIN tag_spec s ON s.tag_id=c.tag_id AND s.effective_to IS NULL
WHERE f.station_gid='${station_gid}' AND f.as_of_date='${biz_date}' AND f.is_current;
```
- **Hot 宽层：拉 P0 宽列**
```sql
SELECT * FROM tag_wide_daily WHERE as_of_date='${biz_date}' AND station_gid='${station_gid}';
```

---

## 8. 与既有交付的关系（如何落地）
- **批次1（治理10表）**：不变；`tag_catalog/spec/enum` 更关键（决定 Tall 的 value_type 与枚举）。
- **批次2（宽表DDL）**：调整为 Hot 宽层用途；P0 字段保持；新增由白名单驱动的生成逻辑。
- **批次3（P0规格卡）**：不变；仅将“输出到宽表”改为“**写 Tall +（可选）入 Hot 宽层**”。
- **批次4（DSL&SQL）**：不变；写入目标从 `tag_wide_daily` 改为 `tag_value_fact` 的对应槽位；宽层由生成脚本负责。
- **批次5（情报源）**：不变；写 Tall 一样有效，Hot 层会自动透视生效。

---

## 9. 运维与监控补充
- **质量**：在 `metric_*` 增加 Tall 专用指标（行数/槽位合规率/trace覆盖率）。
- **延迟**：监控 `tag_value_fact` 的 T+1 SLA；Hot 宽层延迟≤+10 分钟。
- **成本**：trace 外置后，Tall 表 scan 降低 20%+；Hot 宽层仅列展开热点，减少列冗余。

---

### 结语
这版补丁把“结构性扩展问题”一次性解决，同时保留你现有 P0 的上线路径。后续新标签只需要：在治理层登记 → 规则产出 Tall → （必要时）加入白名单即可完成闭环。

